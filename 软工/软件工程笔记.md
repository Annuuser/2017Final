**课程要求**

- 分析建模，数据库概要设计，详细设计，coding，演示
- 答辩时看分析设计的文档和演示项目

# **第一章 **软件和软件工程

软件工程即采用工程的概念、原理、技术和方法来开发和维护软件，将工程管理技术成功的经验和思想与具体软件的开发过程、研究技术相结合，形成一整套适合于计算机软件开发的方法、规范和技术。简言之，即包括一个过程、一组方法和一系列工具。

- 例子：
- CMM、ISO9000
- 传统的测试方法、UML、测试方法等
- 自己开发的shell工具、数据库工具、case(computer aided software engineering)

## 1.1 软件的本质==#掌握==

### 1.1.1 软件工程的定义==#掌握==

#### ==软件定义==

1. 能够完成预定功能和性能的可执行的指令(计算机程序) **代码**
2. 使得程序能够适当地操作信息的数据结构; **数据**
3. 描述程序的操作和使用的文档。**文档**

#### ==#软件和硬件特性的不同==

软件是**逻辑**的而不是物理的产品。 因此， 软件具有与硬件完全不同的特征

将软件与硬件加以区分：

**软件是设计开发的，而不是传统意义上生产制造的**

- 硬件在制造阶段会引入质量问题

- 在人员和工作成果之间对应关系不同

- 产品构建方法不同

- 软件成本主要在于开发设计


- 软件不会“磨损”(wear out)

**硬件失效率关于时间的曲线：“浴缸曲线”**

- 早期高：设计或者生产缺陷
- 中期降低并保持平稳：缺陷被逐个纠正
- 后期再次提高：灰尘、震动、不当使用

##### ==软件失效率关于时间的曲线==

- 理想曲线：随着错误被纠正，曲线降低并平稳
- 实际曲线：软件不会存在磨损，但是软件存在退化(deteriorate)
  - 退化的根本原因：不断的变更
    - 软件退化可由软件重构解决
    - 软件变更时会引入新的错误，曲线陡然上升
    - 在曲线回到最初的稳定失效率状态前，新的变更会引起曲线又一次上升
    - 最小失效率点沿着类似于斜线逐渐上升
    - 变更需求可以来自于利益相关者
  - 每个软件的缺陷暗示了设计缺陷或者从设计转化到机器可执行代码过程中产生的错误
  - 软件生命周期：
    - 开发过程：建模、测试
    - 维护过程
    - 上述两个过程的转换


- 整个工业向着基于构建的构造模式发展，大多数软件根据实际顾客需求定制

**UML图和ER图的区别：**UML图主要是分析设计的模型（用例图,类图,序列图,活动图,状态图等），ER图主要是数据库设计模型。

**ER图和类图的区别：**ER图是一对一多对多的关系，类图是继承或者其他更复杂的关系

**Uml建模是把文字描述从不同的角度进行抽象，从不同的角度建模。**

### 1.1.2 从应用的角度对软件分类==#掌握==

### ==#domains了解==

- 系统软件
- 应用软件
- 工程/科学软件
- 嵌入式软件
- 产品线软件
- Web应用软件
- 人工智能软件
- 开放计算 Open-world computing
  - communicate across vast networks
    - mobile devices
    - personal computers
    - enterprise systems
- 网络资源
- 开源软件

### 1.1.3 遗留软件（legacy software）==#掌握==

- 定义：一些年代较久的软件，旧的程序被称为遗留软件
- 特点：生命周期长，业务关键性，质量差（设计难以扩展，代码费解，文档混乱，测试用例和结果未记录，变更历史管理混乱）
- 发生演化的原因
  - 软件需要进行适应性调整，从而满足新的**计算环境或者技术的需求**
  - 软件必须升级以实现**新的商业需求**
  - 软件必须扩展使之具有与更多**新的系统和数据库交互**操作的能力
  - 软件架构必须进行改建使之能够**适应多样化的网络环境**
  - The software must be adapted to meet the needs of **new computing environments** or technology.
  - The software must be enhanced to implement **new business requirements**.
  - The software must be extended to make it **interoperable with other more**
    **modern systems or databases**.
  - The software must be re-architected to make it **viable within a networkenvironment**.
  - 实例
    - 系统环境的变化
    - 系统需要采用新的技术
    - 系统业务需求的变更
    - 系统的架构需要调整

## 1.2 web软件的特点==#掌握==

### ==#基于web的性质==

#### 属性

- 网络密集性
- 并发性
- 无法预知的负载量
- 性能
- 可用性
- 数据驱动
- 内容敏感性
- 持续更新
- 即时性
- 安全性（非功能性需求的一部分）
- 美观性

## 1.3 软件工程的定义==#掌握==

两个层次

1.将系统化的，规范化的，可量化的方法用于软件的开发、运行和维护

2.在1中所述的方法进行研究

you must recognize a few simple realities:

- The complexity of these new computer-based **systems** and **products demands** careful attention to the interactions of all system elements.
- Individuals, businesses, and governments increasingly rely on software forstrategic and tactical decision making as well as day-to-day operations and control

#### ==#1.3的图 把软件工程抽象==

#### 软件工程定义

**软件工程是（1）将系统化的、规范的、可量化的方法应用于软件开发、运行和维护，即将工程化方法应用于软件。（2）在（1）中所述的方法研究**

- ##### 系统化：需求调研、建模、概要设计、功能设计、详细设计、coding、测试、交互

- 定量化：定量化的管理。例如1000行代码中有2个缺陷。对于超出正常的定量管理时，要采取具体的措施。找到真正的原因和解决方法。

- 规则化：例如uml中的notation。列出数据库中潜在的实体，找到能够代表它们的一些属性。

#### 软件工程是一种层次化的技术

- **根基：质量关注点**
- **基础：过程层。**定义了一个框架。软件过程构成了软件项目管理控制的基础，建立了工作环境以便于应用技术方法、提交工作产品（模型、文档、数据、报告、表格）、建立里程碑、保证质量及正确管理变更
- **技术上的解决方法：软件工程方法。**包括沟通、需求分析、设计及建模、编程、测试和技术支持。
- - 黑盒测试、白盒测试
  - 数据库设计方法、访问数据库方法、保证数据库安全的方法
- 软件工程工具为过程和方法提供自动化或半自动化的支持。将**工具**集成起来建立软件开发的支撑系统，成为计算机辅助软件工程。
- - 方法工具化：CASE计算机辅助软件工程（ computer-aided software engineering）

#### 如何获得高质量的软件

- 软件开发高质量必须要做到软件开发过程化，将各个技术层次结合在一起。

#### SDLC瀑布模型

- 瀑布模型（Waterfall Model）最早强调系统开发应有完整之周期，且必须完整的经历周期之每一开发阶段，并系统化的考量分析与设计的技术、时间与资源之投入等，因此瀑布模型又可以称为‘系统发展生命周期’（System Development Life Cycle, ==**SDLC**==）
  - 需求调研（requirement elicitation、specification）：形成需求规约、采用一些规则的方法进行评审
  - 没有问题后达到一个里程碑（milestone）
  - **分析建模：创建类活动图、序列图。得到需求分析规约。评审**
  - 概要设计：形成概要设计规约。评审
  - 详细设计：每个方法中的流程图（每个方法，每个属性的详细定义，使用流程图来表示）形成详细设计规约。评审
  - 写代码
  - 测试：

#### 测试

##### 按照是否查看程序内部结构：

###### 白盒测试

又称结构测试。这种方法把被测软件看成白盒，根据程序的内部结构和逻辑设计来设计测试实例，对程序的路径和过程进行测试。

方法之一：代码检查

- 桌面检查
- 代码检查
- 代码走查==walkthrough==
  - 核心思想：为了验证不同的工作产品是否符合质量要求。
  - 看代码

###### 黑盒测试

又称功能测试。这种方法把被测软件看成黑盒，在不考虑软件内部结构和特性的情况下测试软件的外部特性。



##### 按照是否运行程序：

###### 静态测试

软件的静态测试不要求在计算机上实际执行所测程序，主要以一些人工的模拟技术对软件进行分析和测试；

* 软件审查(Inspection)技术：最为主要的静态测试手段。
  * 正式技术评审former technical review （**==FTR==**）除了代码之外的软件开发过程中的工作产品保证质量
    * 自测试（one person review）（self-testing）：看文档
    * 小组测试（group review）（group-testing）：看文档

###### 动态测试

通过输入一组预先按照一定的测试准则构造的实例数据来动态**运行程序**，而达到发现程序错误的过程。



##### 按照阶段划分：

###### 单元测试unit-testing

*单元测试*既不属于*动态测试*也不属于静态测试。 *单元测试*既可以使用静态分析，也可以使用*动态测试*

> 是指对软件中的最小可测试单元进行检查和验证。即由测试人员设计测试用例，开发人员编写测试代码，测试人员执行测试用例。

- 单元测试计划
- 单元测试分析和设计
- 单元测试执行
- 单元测试结果分析

###### 集成测试

==以概要设计规约和详细设计规约为依据进行测试==

> 将通过测试的单元模块组装成系统或子系统，再进行测试，重点测试不同模块的接口。

- 可以裁剪（tailoring）裁剪的对象是**==活动==**
- 集成测试例子：A1.0-F1.0都通过了单元测试，B通过修改bug修改为1.2,各个单元的版本不同


- 形成milestone
- 形成集成测试报告和工作产品（用tag标识）

###### 确认测试

> 验证软件的有效性，这就是确认测试的任务，即软件的功能和性能如同用户所合理期待的那样

###### 系统测试

==依据用例图进行测试==

> 将整个软件系统看做一个整体进行测试，包括对功能、性能，以及软件所运行的软硬件环境进行测试。【业务角度】
>
> 系统测试的主要依据是《系统需求规格说明书》文档。

- 把最新的版本更换为作为工作版本
- 系统性能测试：可靠性、安全性等


- 形成milestone

###### 验收测试

==将系统作为黑盒==

> 以用户测试为主，或有测试人员等质量保障人员共同参与的测试，它也是软件正式交给用户使用的最后一道工序。也称交付测试。

* 产品：验收测试报告
* delivery and maintainability and feedback maintain

## 1.4 软件过程==#掌握==

##### 过程定义

**软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。**

- 活动（activity）：实现宽泛的目标
  - 例如：与利益相关者沟通
- 动作（action）：包含了主要工作产品生产过程中的一系列任务。
  - 例如：体系结构设计
- 任务（task）：关注小而明确的目标，能够产生实际产品
  - 例如：构建一个单元测试

##### 过程目的

帮助工作人员挑选合适的动作和任务集合，以高质量且及时的交付项目，以满足项目资助方的最终用户需求

##### 过程框架

###### 框架活动（framework activity）==#掌握==

特点：

* 为实现完整的软件工程过程建立了基础，适用于各种规模的活动。
* 不同案例中软件过程细节可能差别很大，但是框架活动通常一致
* 框架活动可以迭代应用，每次迭代产生一个增量，每个增量实现部分软件特性和功能

包含：

* 沟通
* 策划
* 建模
* 构建
* 部署

###### 普适性活动（umbrella activity）

作用：

**过程框架活动由很多普适性活动来补充实现，普适性活动贯穿项目始终，帮助软件团队管理和控制项目进度、质量、变更和风险**

适用于整个软件过程，为了保证正常活动的高质量进行而进行的活动（配置管理，软件质量保证）

帮助软件团队管理和控制项目进度、质量、变更和风险

**典型的普适性活动**

###### 软件项目跟踪和控制

* 核心思想：进度控制
* 根据历史库估算出每一个步骤需要多久，有多少工作量
* 软件工程跟踪和控制：跟踪的频率自定义
* 四大参数需要跟踪：effort工作量、defect缺陷、size项目的规模、schedule工作时间安排

###### 风险管理

> 对可能影响项目成果或者产品质量的风险进行评估

- 需要评估风险管理所花代价与发生风险后的损失进行比对
- avoiding（风险不发生） mitigation（损失降低）
- 构成
  - 识别风险 identity risks ：
    - 公司中的历史数据，已经做过的项目，有什么问题，从风险库中得到最容易发生的一些风险来匹配自己的项目。
    - 用头脑风暴考虑所有的用户和技术，来讨论会有哪些风险存在。
    - 依靠经验来识别
    - 根据项目本身的特点
    - 计算风险的曝光度 risk exposure（=风险发生的概率probability*风险发生后带来的损失lose（用0-10来评估损失）
  - 风险缓解计划 risk mitigating plan
    - 交叉工作
    - 清楚的项目文档
    - 加强self-testing（结对编程、结对测试）
  - 风险跟踪 risk tracking
    - 基于计划检查质量，是否规避掉了风险，或者是否有所缓解（两种结果）

###### 软件质量保证==SQA==

> 确定和执行软件质量保证的互动

- 定义：在开发过程中，工作产品的形成过程中，监控、检查工作产品的质量
  - uml建模过程中检查建模的过程和规则是否规范
  - 数据库设计的概念（找出潜在的类）、逻辑（明确类之间的关系）、表（根据基本原则）、物理（在具体的数据库中构建）的设计
- 静态测试：技术评审：检查除了代码之外的所有工作产品评审其质量

###### 技术审评

> 评估软件工程产品，尽量在错误传播到下一个活动之前解决并清楚错误

###### 测量

> 定义和收集过程、项目和产品的度量，以帮助团队在发布软件的时候满足利益相关者要求。同时，测量还可以与其他框架活动和普适性活动配合使用

###### 软件配置管理

> 在整个软件活动中，管理变更所带来的影响

- 管理的最小单位，配置项：在开发过程中是一个独立的工作产品
  - 例如：java,.doc
- 作用：
  - 版本控制
  - 协同开发，branch和tag
  - 版本发布

###### 可复用管理

- 定义：定义产品复用的标准（包括软件构件），并且建立构件复用机制
- 增加一些业务的特定的模块进行标准化

###### 工作产品的准备和生产

- 包括了生成产品所必须的活动
- 形成check list

##### 可靠性、可信性、韧性

- 引入可靠性模型：带多参数的函数（每个参数代表开发过程中的一些具体的值），来进行预测
- 模拟：故障注入。主动攻击系统，以观察机器的反应

##### measure、measurement、metrics比较

- measure（测量）：确定一个测量行为

- measurement（测度） ：对于软件的某个属性的定量指示 

- metrics（度量）
  - 对数据进行数学处理，进行加工，模型处理，算法处理，得到的派生的数据
    - 例如平均值在哪个区间之内，符合什么分布
  - **对软件开发过程的定量管理依据**
    - 例如：统计过程模型，statistic process control
    - 根据发现的平均缺陷数
    - 代码质量是不可控的（超过平均错误数量），此时可以让其停下来修改
    - 可控的值是一个范围，不是越小越好，因为与测试环节的质量很有关系


##### 不同项目采用不同的项目过程

主要体现为：

* 活动、动作和任务的总体流程，相互依赖关系
* 每一个框架中，动作和任务的细化
* 等等

1.5 软件工程的实践

1.5.1 实践的精髓

1.5.2 通用的过程

## 1.5 ==#泛读==

实践的关键：

* 理解问题（沟通和分析）
* 计划解决方案（建模和软件设计）
* 实施计划（代码生成）
* 检查结果的正确性（测试和质量保证）

## 1.6 软件神话

##### 管理神话

- 不能通过增加程序员人数而赶上进度。原先的人将本来应该开发的时间放在培训新来的人上
- 将软件外包包给第三方公司，不可以放置不理

##### 客户神话

* 要做到清晰的需求描述

- 变更应该在正式开始开发之前全部确定
- *Until I get the program “running” I have no way of assessing its quality. *
  - 软件质量是在软件开发过程中形成的，没有高质量的规约，也无法设计出高质量的产品。所以要通过review的方式保证软件开发质量    

# 第二章 过程模型

## 2.0 基础

##### 软件过程定义

- 从技术的角度：建造高质量软件所需要完成的活动、动作和任务的框架

##### 过程模型

- 强调对过程活动的任务的详细定义、识别和应用。
- 目的是提高软件质量、项目的客观理性以及对于交付时间和项目费用的可预测性，并对软件工程师构建系统所必须的工作提供指导。

##### 软件工程和软件过程的区别联系

软件过程定义了软件工程化中采用的方法，但是软件工程还包含该过程中应用的技术----技术方法和自动化工具

##### 注意事项

* 根据不同的项目要采取不同的项目模型
* 对于项目模型都要进行评估：目的是改进


## 2.1 通用过程模型==#掌握==

### 基础

##### 过程的定义

在工作产品构建过程中，所需完成的工作活动、动作和任务的集合。这些活动、动作、任务中的每一个都隶属于一个框架或者模型。

##### 软件过程通用过程框架定义

* 五种框架活动：沟通、策划、建模、构建以及部署
* 一系列普适性活动

##### ==软件过程P32页图==

软件过程定义了过程框架

过程框架包括框架活动和普适性活动，普适性活动分布在整个项目过程中

每个框架活动包括多个软件工程动作

每个软件工程动作由任务集合来定义

每个软件工程任务集合明确了

* 将要完成的**工作任务**
* 将要产生的**工作产品**
* 所需要的**质量保证点**
* 表明过程状态的**里程碑**

##### 过程流

描述了在执行顺序和执行时间上，如何组织框架中的活动、动作和任务

- 线性过程流：从沟通到部署顺序执行五个框架活动
- 迭代过程流：执行下一个活动之前重复执行前一个或多个活动
- 演化过程流：采用循环的方式执行各个活动，每次循环都能产生更为玩产的软件版本
- 并行过程流：将一个或多个活动与其他活动并行执行

### 2.1.1 框架活动==#掌握==

对于小型项目：

- 主要的活动activity：沟通
- 主要的动作action：
- 主要的四个任务tasks
  - 通过电话与利益相关者取得联系
  - 讨论需求并记录
  - 将笔记整理成一份简单的书面需求
  - 通过E-mail请利益相关者审阅并批准
- 对于复杂的项目：
  - 沟通活动包含六个不同的动作
    - 启动：确定大体人员
    - 碰头：从不同的角度进行分析讨论
    - 进一步细化：每一个点怎么考虑，每一个功能怎么确定
    - 谈判：讨论各方的要求
    - 初步需求规约
    - 验证评审
  - 每个软件动作都有可能很多工作任务和一些不同的工作成果

### 2.1.2 任务集==#掌握==

==课程材料中有参考资料==

**定义了为达到一个软件工程动作的目标所需要完成的工作**

##### 如何识别任务

- 根据目的识别任务
- 根据经验是别任务：经验支持，可以用例子来学习，从而获取经验
- 根据实际情况识别任务

##### 框架活动的action，task

* 活动activity：communication沟通
* 动作：需求获取（elicitation）（requirement gathering）
  * 目的：理解利益相关者对于将构建的软件的需求
* 任务集合
  * 小型项目6个
    * **找出一个项目所有的利益相关者==考试==**：
      * 国家税务系统的利益相关者stakeholders
        * 税务局里面的业务人员，技术人员
        * 开发方的技术人员和管理人员（架构师）
        * end user 选择代表来参与讨论
        * provider 软硬件的提供商
          * 如果缺少了提供商代表，oracle，对于不同的数量的用户的适应，选择同时的并发的数据量
          * 从提供商的角度来建议购买选择
    * 邀请所有利益相关者参加一个非正式会议
      * 介绍项目，听取不同角度的意见
    * 征询每一个人对软件特征和功能的需求
      * 基于web的平台，受众是全国各地的人员，基于云端的application
      * **考虑哪些系统的feature：性能、安全性、用户最高的峰值、移植性（不同的平台）、兼容性**
    * 讨论需求，并确定最终的需求列表
      * 需求文档要规整
      * 讨论、检查以后获得较为完整的需求列表
    * 划定需求优先级
      * 先把重要的开发出来，再去考虑后期完善
    * 标出不确定领域
      * 无论是feature还是function，都会有暂时无法被确认的内容
      * 后来开发过程中产生的问题
  * 大型项目12个
    * 明确利益相关者
    * 对于每一个利益相关者单独讨论，得到所有需求的汇总
    * 构建最基本的功能和特征列表
    * 安排一系列促进需求获取的会议，应该有一个各个会议的参与者参与者、时间节点和目的的确定
    * 组织会议
    * 在每次会议上建立非正式的用户场景，要根据模拟的用户实际场景来进行需求的获取
      - use case diagram
      - 抽象、讨论、完善
      - 诱导需求而使用的use case
    * 根据利益相关者的反馈，进一步细化用户场景
      - 明确到用户使用的细节
      - 进一步细化和优化
      - 去想每一个功能怎么实现
    * 建立一个修正的需求列表
    * 使用质量功能部署技术，划分需求优先级
    * 将需求打包以便于软件可以增量交付
      - 把明确好的需求打包发布
      - 根据优先级的高低来发布
      - 敏捷模型
    * 标注系统的**约束和限制**
      - **法律法规的限制**：国家利益、隐私信息、微信中有自动检测的功能
      - **来自于甲方成本的的约束和限制**：费用的限制、根据费用来确定哪些功能要实现
      - **技术层面的限制**：某些技术不成熟、有风险、现有的技术无法实现的功能需求
      - **业务的限制：**要访问国家安全部门的身份证信息网，在需求调研的时候，为了使得系统达到实名制，要与国家部门进行业务限制
    * 讨论系统的验证方法
      - 调研过程，多个任务的不断循环迭代
        - 大循环
          - 其中某一个task效果不太好，把前面的过程再来一次
          - 需求调研十分重要
        - 小循环

- problem：比较重大的问题
- issue：过程流中遇到的问题，该问题往往不难但不解决会影响项目的进程
- question：过程遇到的问题

##### umbrella activity的action，task

- activity：软件配置管理Software Configuration Management

- action：忘记是什么动作了，好像动作也是配置管理

- tasks：

  1. ##### **配置管理的前期准备**SCM inception

  - 用什么工具、什么环境来构建配置管理的工作
  - 人员的组织，通常只有一个专职人员，board委员会，在需要做决议的时候可以集合开会

  2. ##### **scm plan：Software *Configuration Management Plan***

  - 配置管理的时间节点
    - 时间：找到相似的项目，根据其所花费的时间来初步估计当前的时间
  - 配置管理的对象
  - 配置管理的流程
    - 发现缺陷
    - 提交缺陷
    - 向配置管理人员申请修改
    - 配置管理把有错误的部分放到工作空间
    - 发送修改通知
    - 测试
    - 完成
  - ==（**考试**）配置管理的任务是一个离散的任务，是松散的活动，不是完成了就结束了==

  3. ##### **实施：根据计划和时间安排实施项目**

  4. ##### SCM软件配置管理 QA：检查实施的效果

  5. ##### 经验的总结和分析，以达到持续改进

     - 优点：共享
     - 缺点：下次改进

- 可以根据执行效果来评判任务集的可行性


- 过程、能力承受度模型
- 软件过程可以定义、可以裁剪

### 2.1.3 process pattern==#掌握==

过程模式描述了软件工程工作中遇到的过程相关的问题，明确了问题环境并给出了针对该问题的一种或者几种可证明的解决方案

某个问题任务不知道怎么实现，可以去找对应的pattern来参考

模式可以描述一个与完整过程模型相关的问题和解决方案，例如原型开发

模式可以描述一个框架活动或者某一项具体任务相关的问题，例如策划和项目估算

- 模式名称：清除表达模式在软件过程中的含义（系统测试、技术评审）
- 驱动力：模式使用的环境和主要问题，明确主要难点以及可能影响的解决方案
  - problem：严重的问题
  - question：较为中性，客户提出的亟待解决问题，可能会包含problem
  - 问题issue：
    - 需要客户确认一下验证密码是六位还是八位，第一位要不要大写
    - 网络问题
    - 不难解决，但是不解决会影响进程
    - 对于确定场景的细节不缺定的问题
    - 对于技术的具体实现细节
- 类型：
  - **步骤模式（stage pattern）：activity，stage。定义了过程框架活动的问题，步骤模式包含许多任务模式**
    - **例如建立沟通**
  - **任务模式（task pattern）：task**定义了与软件工程动作或是工作任务相关、关系软件工程实践成败的问题
    - **例如需求获取**
  - **阶段模式（phase pattern）：定义在过程中发生的框架活动序列**
    - **螺旋模型**
    - **原型开发**
- 启动条件：上下关联，前提条件
  - 策划模式（阶段模式）的启动条件：
    - 客户和软件工程师已经建立了合作的交流机制
    - 已经成功完成一些客户沟通模式中特定的任务模式
    - 项目范围、基本任务需求和项目限制条件
- 问题：模式要解决的问题的说明
- **解决办法：**描述如何成功实现模式
- 结束条件：
  - 必须完成哪些开发组织或者开发团队相关的活动
  - 结束状态是什么
  - 产生了哪些软件工程信息
  - pattern去解决问题之后的出口条件和出口准则
- 相关模式related pattern：以层次或其他图的方式列举与该模式直接相关的其他过程模式
  - 相关的可能会使用到的其他的pattern
    - 需求调研会用到另一种pattern
    - 步骤模式沟通包括了一组任务模式：项目团队组织、合作指导原则定义、范围分解、需求获取、约束描述、场景模式的创建
  - ==解决方案的嵌套，相关的pattern之间是否有包含关系（**选择题**）==
- 已知应用实例

## 2.2 过程评估与改进==#掌握==

==CMM五个LEVEL的过程域，书上不重要==

### 基础概念

##### CMM

能力成熟度模型（==CMM==, Capability Maturity Model）CMM共有五个等级，分别标志着软件企业能力成熟度的五个层次。从低到高，软件开发生产计划精度逐级升高，单位工程生产周期逐级缩短，单位工程成本逐级降低。

##### CMMI

能力成熟度模型集成（英文：Capability Maturity Model Integration，简称**CMMI**或“希迈”）是一个过程改进方法，它的目的是帮助组织改进他们的绩效。“ 希迈”可以被用于引导横贯一个项目、一个部门或一个完整的组织的过程改进。

##### SCAMPI

用于过程改进的CMMI标准评估方法

五种评估模型：

* 启动（initiating）
* 诊断（diagnosing）
* 建立（establishing）
* 执行（acting）
* 学习（learning）

##### CBA IPI

用于组织内部过程改进的CMM评估，可以分析软件开发机构相对成熟度

##### SPICE

定义了软件过程评估的一系列妖气。目的是帮助软件开发组织建立客观的恶评价体系，以评估定义的软件过程的有效性

##### 软件ISO

一个通用标准，任何希望提高所提供的产品、系统或服务的整体质量

### CMM

***CMM*是指“能力成熟度模型”，其英文*全称*为Capability Maturity Model for Software**

#### CMM五个等级

**图中黑点：关键==过程域Kpa:key process area==**

*关键过程域*，是企业需要集中力量改进的软件过程，用于达到增加过程能力的效果

每个等级都被分解为过程域，特殊目标和特殊实践，通用目标、通用实践和共同特性：

每个等级都有几个过程区域组成，这几个过程域共同形成一种软件过程能力。每个过程域，都有一些特殊目标和通用目标，通过相应的特殊实践和通用实践来实现这些目标。当一个过程域的所有特殊实践和通用实践都按要求得到实施，就能实现该过程域的目标。 

CMM1：初始级，Inltial，不可预测并且缺乏控制； 
CMM2：可重复级：Repeatable，可重复以前的主要经验； 
（关键过程区域：需求管理；软件项目计划；软件项目跟踪和监督；软件子合同管理；软件质量保证；软件配置管理。） 
CMM3：已定义级：Defined，过程被描述，并得到良好理解； 
（关键过程区域：组织过程定义；组织过程焦点；培训大纲；集成软件管理；软件产品工程；组际协调；同行评审。） 
CMM4：已管理级：Managed，过程被测量并受控； （关键过程区域：定量的过程管理；软件质量管理。） 

CMM5：优化级，Optimizing，关注过程改进。 
（关键过程区域：缺陷预防；技术变更管理；过程变更管理。）

##### Level1 Initial初始级

- 个人英雄主义
- 软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。

##### Level2 Repeatable可重复级

六项工作做完以后公司中的其他项目可以重复使用

已管理级 建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。

###### what to do

- **需求管理**
  - 对需求变更进行管理，使用需求变更规范文档
    - 明确记录需求变更内容
    - 对需求变更进行评估：交付时间、费用的影响
    - 交给上一级人员review
    - 确定影响的模块，需求分析规约，概要设计规约应该怎么修改
    - 更改的任务分配，对相关应该修改的内容进行评审
    - 必要时对代码进行修改
  - case：computer analysis software engineering
- **软件项目计划**
  - 使用mms的工具
  - 贯穿整个过程，经常会变化
- **软件项目跟踪和概览**
  - 跟踪模型跟踪频率
    - **每天**站会
- **软件子合同管理**
  - 外包的管理


- **SQA工作**
  - 制定qa人员
  - checklist
- **配置管理**
  - 按照配置管理计划来进行要求

###### how to do

- 每一个kpa都要有形成规范文件
  - 数据库设计规范、java规范、需求变更规范
  - 可以使用模板
- 配置工具
- 管理和监督机制

##### Level3 Defined 可定义级

**提升软件过程开发能力和质量控制**

已定义级 已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。 

- **组织过程聚焦**
  - 关注开发过程，每个里程碑点的完成时间和计划时间的偏离程度，每个product的完成质量
- **组织过程定义**
  - Tailor：文件裁剪指南
    - 每一次sprint中的标准工作，对开发的过程进行裁剪
    - 在第一次sprint中完成哪些环境，在后续的sprint中合并某些任务


- **Traning program培训项目**
  - 根据项目内容定义培训内容
  - 业务培训、数据库培训、技术培训
- **集成的软件管理**
  - 针对离散的任务：分布在很多的activity或者action中
  - 配置管理、qa工作、项目管理工作、项目经理的工作
- **软件产品工程**
  - 控制产品发布
  - 敏捷模型：迭代几次发布，每一次迭代的时间（h）、工作量和最后是否能交付
- **组织和协调**
  - 通过工具沟通协调：更改概要设计、详细设计、代码
- **同行评审**
  - 规范文件
  - formal technical review不检查代码
  - 静态测试

##### Level4 Managed管理级

难点：quantitative process：定量管理

分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。

- 软件质量管理=缺陷管理
  - **四大参数需要跟踪（定量管理）**
    - **effort工作量**
    - **defect缺陷**
    - **size项目的规模**
    - **schedule工作时间安排**
  - DRE:defect remove efficiency 缺陷移出效率
    - 内部缺陷管理：某个阶段
      - **在过程的某个阶段，对规约进行评审，发现的缺陷是D，当前阶段没有发现而后期发现的因为当前阶段导致的缺陷数量是E**
      - **反应的是某阶段的移除概率**
      - D/(D+E)
        - D代表在需求阶段发现的错误
        - E代表在分析阶段没有发现没有处理，在后续阶段才被发现的问题
      - 例如在需求分析阶段的移除率
    - 外部缺陷管理：所有开发阶段发现的缺陷错误数量
      - **所有阶段发现的缺陷是D，在这些阶段没有检查出来，后期用户测试发现的是E**
      - D/(D+E)
        - D项目完成过程中发现的缺陷数量
        - E客户做验收测试发现的缺陷数量
  - 总的项目和代码阶段的管理
    - 评审代码后每千行代码的错误数量是不是低于标准
    - 第一个月中对所有的代码缺陷按照严重性进行分类、按照类型分类并对比例进行标记
- 过程质量管理

##### Level5 Optimizing优化级

过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。 

- 过程改变管理
  - 项目实施过程中的改变
- 技术改变管理
  - 例如数据库的改变
- 缺陷预防

- 步骤

## 2.3惯用过程模型

所有的软件过程模型都支持第一章描述的通用框架活动个，但是每一个模型都对框架活动由不同的侧重，并且定义了不同的过程流以不同的方式执行每一个框架活动（以及软件工程动作和任务）

### 2.3.1 瀑布模型==#掌握==

waterfall model 瀑布模型

classic life cycle 经典生命周期

##### 过程

沟通

* 项目启动
* 需求获取

策划

* 项目估算
* 进度计划
* 项目跟踪

建模

* 分析
* 设计

构建

* 编码
* 测试

部署

* 交付
* 支持
* 反馈

##### 特点

- 最早的经典的模型
- 一个系统的顺序的软件开发方法
- 模型的理论在不同的阶段没有中断(break)或者反复或者迭代
- ==所有的核心需求百分之九十以上都需要明确==
- 开发周期长
- 弹性差

##### 缺点

- 开发过程中断时，整个项目都会中断，没有并行开发来弥补
- 整个项目需要两年的时间才能出成果，中途没有成果展示

#### v模型

##### 定义

瀑布模型的变体，描述了质量保证活动同沟通建模相关动作以及早期构建相关动作之间的关系

##### 使用方法

* 软件团队工作沿着v模型左侧步骤向下推进，基本问题需求逐步细化，形成问题及解决方法的技术描述
* 编码结束，团队沿着v模型右侧的步骤向上推进工作，本质上是执行了一系列测试（质量保证动作）
* 这些测试验证了b模型左侧向下推进的每个模型

##### 模型解释

- 需求和分析都在第一个阶段
- 最后有一个support
- 拉直是一个瀑布模型

##### 最大的贡献

==开发阶段和测试阶段的依赖关联==

- 软件测试的活动依赖于v活动左边活动的工作产品的

- 在做集成测试的依据是箭头所指的活动的工作产品

- 例子

  - **单元测试（Unit testing）：看详细设计规约和代码**
    - 详细设计规约
      - 函数的命名，参数
      - 函数被哪些函数调用，会调用哪些函数
      - 函数实现的逻辑流程图和伪代码
  - **集成测试**（Integration testing）依据：
    - **详细设计规约**（detailed design specification）（component design specification）
    - **概要设计规约**（architecture design specification）（high level design specification）
    - **概要设计三个重要组成部分**
      - 模块之间的调用关系图
      - 数据库设计
      - 接口设计
  - 系统测试（System testing）：
    - 把工作产品放到真实的工作环境中进行测试
    - **根据概要设计和需求**进行测试
  - 验收测试
    - 甲方把产品当做黑盒
    - 只根据**需求**进行测试

- 变化流

  - 特性
  - 功能
  - 信息内容的变化
    - 输入输出数据的格式的变化

  ​

### 2.3.2 增量过程模型

综合了线性过程流和并行过程流的特征

增量模型在每个阶段运用线性序列，每个线性序列以一种演化的过程流生产增量类似的方式产出一个软件的可交付增量

##### 特点

- 第一次增量：包含core product，包含了核心功能
- 客户使用核心产品进行仔细评价，根据评价结果指定下一个增量计划，每一个增量的交付都重复这一个过程
- 后续增量：完善第一次增量
- 每一次增量之间可能有交叉并行
- 每一个增量的开发从理论上来说是一个瀑布模型

##### 使用场景

- 时间：短期可以使用初期产品
- 技术：oracle中的并行服务处理
  * 前期的增量用磁盘阵列，在后期的增量中再采用新的技术
- 资金：return of investment
  * 前期投入部分资金
- ==需要主要需求比较明确==

##### 例子

采用增量模型开发的文字处理软件

第一个增量：提供基本文件管理、编辑和文档生成功能

第二个增量：提供复杂编辑和文档生成功能

第三个增量：提供拼写和语法检查功能

第四个增量：提供高级页面排版功能

任何增量的过程流可能使用原型模型

### 2.3.3 演化模型==#只用掌握原型模型==

##### 定义

**商业和产品需求经常发生变化，直接导致最终产品难以实现，必须交付功能有限的版本应对竞争或商业压力**

**很好的理解了核心产品和系统需求，但是产品或者系统扩展的细节没有定义，用来应对不断演变的软件产品的过程模型**

##### 与增量模型的差别
每一次的演化都不是可以发布的产品，仅有最后一次演化的工作产品可以发布
##### 演化过程模型
###### 原型开发模型==#掌握笔记里面的内容==

特点：能够运行的原型，但是不能供给客户使用
* 演化迭代的模型
* 用来调研需求，帮助软件开发人员和利益相关者更好的理解究竟要做什么
* 可以全盘抛弃
* 原型完成后可以用瀑布模型和增量模型进行开发


# 第三章 敏捷开发==#掌握==***\*\*\*

==看参考文档，找一个实际项目看怎么做的==

==文档：课程教材等资料==

每次演化的结果都更加接近最终产品

基本动力：普遍存在的变化

##### 敏捷原则

- 个体与交互 胜过 过程与工具
- 可以工作的软件 胜过 面面俱到的文档
- 客户协作 胜过 合同谈判
- 相应变化 胜过 遵循计划

### 3.5.3 Scrum

Scrum是一种敏捷开发过程模型（强调**适应改变**），是一个增量的、迭代的开发过程。这种开发模型的**各个阶段相互重叠**，并且由一个**跨职能团队**通过不同的阶段完成整个开发过程。

Scrum框架的整个开发周期包括若干个小的迭代周期，**每个小的迭代周期称为一个Sprint**，每个Sprint建议长度为2至4周。

在Scrum中使用**Backlog来管理工作产品或者项目的需求**，backlog是一个按照商业价值排序的需求列表，列表条目体现形式通常为用户故事。在每个Sprint中，Scrum开发团队从Backlog中挑选最有价值的需求进行开发。

**一种敏捷开发过程模型（强调适应改变）**

使用一组软件过程模式，每个过程模式定义一系列开发活动：

#### 开发活动

##### sprint冲刺

每一个框架活动中，发生于一个过程模式中的工作任务称为一个冲刺

由一些工作单元组成，这些工作单元是达到待定项中定义的需求所必须的，并且必须能在预定的时间段内完成。冲刺过程中不允许有变更

* 每个小的迭代周期叫做sprint
* 每个sprint的长度2到4周
##### backlog待定项

管理工作产品或项目需求

一个能为用户提供商业价值的项目需求或者特征的优先级列表。待定项中可以随时加入新项

* 按照商业价值排序的需求列表
* 列表的体现形式为用户故事
  Scrum开发团队中从backlog中挑选最有价值的需求进行开发

##### sprint backlog

每一个sprint的任务列表

##### Scrum每日站会（daily meeting）

团队每天进行15分钟的检验和适应的会议成为Scrum每日站会

#### Scrum角色
##### 产品负责人

- 负责确定产品的功能、发布日期、发布内容；负责产品的ROI（Return On Investment）；
- 在每个Sprint开始之前调整功能和优先级；
- 接受或者拒绝开发团队的工作成果；
- 参与Scrum planing

* 参与整个scrum planning
##### scrum master
* 将Team Leader和Product owner紧密的联系在一起。
* 及时为团队成员提供帮助。
* 保证团队资源完全可被利用并且高产出；
* 保证各个角色只能的良好协作；
* 解决团队开发的障碍；
* 作为团队和外部的接口，屏蔽外界对团队成员的干扰；
* 保证开发过程按照计划进行，组织Daily Scrum，Sprint Review and Sprint Planning meetings；

##### 团队
* 人数通常在5-9人，团队要**跨职能**并且全职（包括开发人员、测试人员、用户界面设计师）；
* 尽一切努力做任何事情确保达到Sprint的目标；
* 高度的**自组织**能力；
* 在sprint内成员不变化；
* 团队**整体**向产品开发负责

#### 工作产品
##### backlog
有优先级的故事列表，估算故事点
##### spring backlog
当前spring要完成的任务列表，估算工时
* 团队成员自己挑选任务而不是指派任务
* 每个任务，每天要更新剩余工作量估计
* 每个成员都可以修改spring backlog
##### 燃尽图
发布燃尽图（burn down chat）：直观反映当前发布剩余工作量，以Sprint周期数和故事点为单位。Y表示剩余的工作，X表示Sprint的时间

#### Sprint过程
##### Sprint计划会议

- 团队从产品中挑选承诺完成的条目（做什么）
- 创建Sprint Backlog（怎么做）
- 标识具体的任务并且为任务做估算
- 由团队协作完成，而不是Scrum Master
- 考虑了高层设计（架构设计）
  - 第一次的scrum中概要设计很重要
- **概要设计三个重要组成部分**
  - 模块之间的调用关系图
  - 数据库设计
  - 接口设计

##### Scrum每日站会（daily meeting）

团队每天进行15分钟的检验和适应的会议成为Scrum每日站会，汇报工作如下

- 从上次会议到现在完成了哪些工作
- 下次会议前准备完成什么
- 工作中遇到了哪些障碍

##### sprint评审

为产品拥有者演示sprint中开发的产品功能

##### Sprint回顾会议

全体讨论有哪些好的做法可以启动，哪些不好的做法不能继续下去了





# 第四章 指导实践的原则==#掌握不要背要理解==

半衰期的概念 software development knowledge has a 3-year half-life	

### 4.2.1 基于过程的基本原则==#掌握==

##### 原则1：灵活性

评估师制作标准的过程，执行时候进行裁剪以更加适合真正的模型

* 针对不同的人的代码对walkthrough做调整
* 配置管理根据项目大小来调整

##### 原则2：过程中每一步关注质量

使用defect remove efficiency

##### 原则3：使用多种解决策略

##### 原则4：构建有效的团队

考虑技术要求、个人能力、项目时间长短

考虑的因素

1. 业务
2. 技术（数据库、架构、语言）
3. 人员数量（不是越多越好、高峰期：coding、testing）
4. 经验

##### 原则5：有效的沟通机制

##### 原则6：变更管理

提出需求、影响分析（评估）、批准、实施

##### 原则7：风险评估

##### 原则8：生产工作产品提供给下一阶段

### 4.2.2 activity(称为practice)的原则==#掌握==

软件工程活动的目标：按时交付、高质量、可操作性强的、满足利益相关者的功能特性要求的产品

所有活动都要遵循

##### 规则1：分而治之

##### 系统分解：

技术逻辑分解：

业务逻辑分解：

功能分层：不是逻辑分解，体现功能的接口关系

##### 原则2：理解抽象的使用

不同的建模是不同角度的抽象

class diagram：实体类的抽象，帮助我们设计类、继承、数据库

use case：用户产品的抽象

sequence diagram：对象之间的动态交互抽象

state diagram：每个类中调用的抽象

##### 原则3：努力达到前后一致

不同的过程并行、相互依赖

分析建模中的功能来源于需求规约的需求分析

需求规约中的**实义名词**，就可能是我们要设计的类

实义名词：有属性，这个数据是系统中需要保存的数据

##### 原则4：注意接口设计，信息流

接口的设计

**信息流**通过接口流动来输出

转换、输出

##### 原则5：有效的模块设计

进行类的模块化

##### 原则6：查找模板

遇到问题的时候通过找模板解决问题

##### 原则7：从多角度分析、评估、解决问题

**集成方案**

基于路径的集成

集成类的方法：

自上而下的集成

自上而下的集成

A、B两个不同类（功能）中的之间的调用很频繁

解决方案：减少内部的接口

1. 合并两个类，如果功能不相近，达不到功能的独立性

##### 原则8：所有的工作都应该有文档

项目的组成部分data、documentation、coding

为后期的维护做准备

### 4.3.1 communication原则==#掌握***==

需求调研

##### 原则1：听甲方的要求

##### 原则2：交流之前做准备

domain jargon

##### 原则3：有一个活动协调人

活动：需求调研

召集、组织、形成需求草稿

尽量避免冲突发生

##### 原则4：最好面对面交流

##### 原则5：记录并形成文档

##### 原则6：努力达成合作

##### 原则7：模块化，分解问题

##### 原则8：用图表

##### 原则9：暂放无法解决的问题

##### 原则10：谈判不在乎输赢

### 4.3.2 计划原则==#掌握==

理解范围、stakeholder、迭代计划（周、milestone）、估算、

内部功能，外部接口，非功能需求

##### 原则3：计划是可迭代的

根据实际情况不断的更改

##### 原则：规避风险

大项目需要有缓冲的余地

风险跟踪、转换为task

##### 原则：考虑粒度

主要针对task

项目计划发展的时候详细的程度

### 4.3.3 通用建模原则==#掌握==

需求分析建模、概要设计建模和详细设计建模

需求模型从三个不同域描述软件来表达客户的需求：信息域、功能域、行为域

设计模型表述了可以帮助开发者高效开发软件的特征：架构、用户界面、构建细节

原则1：软件团队的主要目标是构建软件而不是创建模型

原则2：不创建任何不需要的模型

原则3：尽量创建能描述问题和软件的最简单模型

原则4：用能适应模型改变的方式构建模型

原则5：明确描述创建每一个模型的目的

##### 流模式、结构化开发：

**功能、数据、行为建模**

class diagram：数据建模

sequence diagram：行为建模：**帮助做接口设计**

##### 面向对象开发：

**功能、数据、行为建模**

architecture、user interface

调研得到需求规约

分析建模规约

类图ERD

#### 4.3.3.1 分析建模原则

原则1：描述并理解问题的信息域

原则2：确定软件需要实现的功能

原则3：描述软件的行为

原则4：描述信息

原则5：分析任务从本质信息转向实现细节

##### 三种建模

三种建模可以不断的迭代

##### 数据建模

类图、ERD

* 流入数据和流出数据
* 永久性存储的数据

##### 功能建模

###### activity diagram

面向对象建模：主要是activity diagram，把整个系统层面的业务流描述出来

###### DFD data flow diagram

结构化开发、流模式开发：数据流图

##### 行为建模

state diagram

事件、状态、状态图

#### 4.3.3.2 设计建模原则

**包括：技术逻辑抽象、业务逻辑抽象**

**模块调用关系图**

原则1：设计建模以分析建模为依据

原则2：始终关注待建系统的架构

原则3：数据设计（模块内部的数据结构设计）和功能设计一样重要

- 数据设计
- 数据库设计
- 数据仓库设计
- 数据标记设计

原则4：精心设计接口（内部接口和外部接口）

原则5：用户界面设计符合最终客户要求

包括两个。。啥

原则6：构件级设计功能要独立

原则7：构建之间以及构建与外部环境之间松散耦合

##### 内聚：cohesive

高内聚：好的功能独立性

##### **耦合：coupling**

**接口设计就是模块之间的耦合**

低耦合：不同的模块之间的调用的参数的设计尽量简洁。参数数量、实参的值等

耦合可以通过接口、消息传递、全局数据。随着耦合程度的提高，错误传播的几率也会随之提高，整个系统的维护性会降低

参数少、传输数据简单

### 4.3.4 construction构造原则

测试：

1. 单元测试：构建级别的测试
2. 集成测试：在构建系统时候进行
3. 确认测试：测试系统是否完全按照需求开发
4. 验收测试：由客户检验系统所有要求的功能和特性

#### 4.3.4.1 coding原则

##### 准备原则

* 代码要解决的问题，参考详细设计，了解输入输出
* 理解设计原则和概念、代码接口、代码逻辑、入口出口
* 代码调用和被调用的情况
* 选择语言
* 考虑语言的集成开发环境IDE
* 创建单元测试，unit testing，self-testing,**主要测试功能**

##### 开始原则

* 选择特定的算法，考虑时空复杂度
* 结对编程
* 选择数据结构
* 理解软件体系结构、理解接口（类内部调用，和类之间的调用）
* 条件逻辑尽量简单，尽量少用if之间的嵌套
* 减少循环套用
  * 边界值测试：
    * 从里向外面嵌套，最内层循环中的循环变量设定一个常量，测试外层循环，
    * 小大边界值，中间值，通常选择7个，
    * 再把当前循环循环变量用一个固定值替代，再向外层循环测试，选择7个测试值
* 变量命名一定要规范，英文的缩写的规范message msg
* 注释充分
* 代码布局，空行

##### 结束原则（确认原则）

* 走查，静态测试
* 动态测试，self-testing：小项目。self-testing+unit testing：大项目
* refactor重构
  * 重命名，更容易理解
  * 抽取代码，更加有通用性
  * 封装字段，控制字段访问
  * 抽取接口
  * 提升方法类的局部变量为方法参数
  * 确定先后次序
  * 删除不必要参数

#### 4.3.4.2 Testing原则==#掌握***==

* 测试是一个以发现错误为目的过程
* 好的**测试用例**可以帮助增大找到未发现的错误的可能
  * 插卡、输入密码、输入金额
  * 测试用例：被测试，卡号，在数据库中找到卡号，给出余额，减去一千，输出
  * 比较expected output和actual output
* **一次成功的测试**可以发现未发现的错误


原则


1. 回溯到用户需求（v模型）
2. 测试的计划在测试之前就着手  
3. pareto principle 在这个上下文下，在测试过程中百分之八十的错误，可能是由百分之20的代码引起的。80-20规则

   1. 帕累托法则（英语：*Pareto principle*）， (也被称为80/20 法则, 是重要的少数的法则， 也是因素稀疏的原则) 指出，对于许多事件的影响大约80％来自的原因20％ 
   2. 分离高可疑的构建，找出百分之二十的程序来重点测试
   3. 对base business path进行测试（100），每个测试用例对应一个path
   4. 其中许多缺陷都是由于某几个基本业务路径相关而引起的，那这些基础业务路径就是测试重点
   5. 修改后需要再次测试的时候，可以只测试重点测试路径
4. 微观到宏观
5. 穷举测试是不可能的

#### 4.3.4.3 部署原则deployment

部署包括三个动作：交付、支持和反馈

* support&feedback的原则
* 后两者叫做maintainess

部署活动并不是只发生一次，而是在软件完全开发完成之前进行许多次。

* 每个交付周期都会向客户和最终用户提供一个可运行并具有可用功能和特征的软件增量。
* 每个支持周期都会为部署周期中提到的所有功能和特征提供一些文档和人员帮助。
* 每个反馈周期都会为软件开发团队提供一些重要的引导，以帮助修改软件功能、特征以及下一个增量用到的方法。

原则：

每次交互考虑是否满足客户预期

完整的传输包应该经过测试和安装

交互以后应该有一个维护的团队

安装手册、使用手册、维护手册

维护手册最困难

在出现异常的时候的解决思路

bug必须要fix

#### 总结

process level原则

每个阶段需要遵守的原则activity practice

modeling

概要设计architecture

详细设计component

construction

coding

testing

**The Difference Between Customers and End Users**	

## 客户与最终用户之间的差别：

软件工程师与许多利益相关者交流，但是客户与最终用户对将采用的技术影响最大。有的时候客户与最终用户是相同的人，但是对于许多项目来说，客户与最终用户是不同的人，为不同商业组织的不同管理者工作。

##### 客户

1. 最初要求构建软件的人 
2. 为软件定义全部业务目标的人 
3. 提供基本的产品需求的人
4. 为了项目协调资金的人

在产品业务或者系统业务中，客户通常是销售部门

在IT环境下，客户或许是一个业务单位或者部门

##### 最终用户

为了达到某种商业目的而将真正使用所编写软件的人

为达到其商业目的将定义软件可操作细节的人

# 第五章 理解需求

==阶段的英文==

从需求工程的角度来整理

## 5.1 需求工程==#掌握==

### 需求工程

#### Inception启动

确定利益相关者

开会明确功能，明确要解决什么问题

• ==确认利益相关者：业务运行管理人员、产品管理人员、市场销售人员、内部和外部客户、最终用户、顾问、产品工程师、软件工程师、支持和维护工程师以及其他人员==
==• 利益相关者：软件团队成员、软件工程师、市场销售人员、产品工程代表，甲方，数据库提供商，潜在的硬件提供商，传感器的提供商==

#### Elicitation调研

导出。询问客户、用户和其他人系统或产品的目标是什么，想要实现什么。列出所有利益相关者，得出一个需求规约的草稿

#### Elaboration建模细化

精化。在初始和导出阶段获得的信息将在精化阶段进行拓展和提炼。

主要任务时建模。数据建模、功能建模、行为建模。完善需求规约

功能建模、数据建模、行为建模，从功能角度，性能角度，系统约束，每个stakeholders阐述

#### Negotiation交流谈判

协商。不同的用户可能会提出相互冲突的需求，需求工程师必须通过协商过程来调解这些问题

#### Specification需求规约

产生需求规约和需求分析规约，以文档形式表示，有图或公式

#### Validation评审验证

确认。对需求工程的工作产品进行质量评估

#### Requirement management需求管理

需求管理。需求发生变更后进行管理。



需求工程的步骤：

##### 需求诱导

需求诱导注意三个方面的问题：范围问题、理解问题和易变问题

##### 需求分析谈判

根据需求诱导的结果进行需求分析，系统工程师必须通过必要的谈判来解决系统需求间的冲突，并讨论和每个需求相关的风险。

##### 需求分析规约

系统需求规约可以是一分写就的文档、一个图形化的模型等。它是系统和需求工程师的最终各种产品，它将作为硬件工程、软件工程、数据库的工程以及人力工程的基础。它描述了基于计算机系统的功能和性能以及对开发的控制和约束。规约界定了每一个分配的系统元素。

##### 系统建模

计算机系统可用输入---处理---输出的模板来建模作为信息变换，后来又扩展了该视图包括两个附加的系统特征—用户界面处理和维护和自测试处理。它们使系统规约更健壮。系统工程师使用系统特征创建一个系统构件模型，这个模型是系统构件中每种工程方法的需求分析和设计的基础。

##### 需求确认

需求确认将检查规约以保证系统需求地陈述无歧义、不一致、疏忽和错误，并符合过程、项目和产品建立的标准。确认的机制是FTR。

##### 需求管理

是一组在项目进展中标识、控制和跟踪需求的活动。这类活动是通过类似配置管理技术来实现的。需求管理赋予每个需求惟一的标识符，一个可能的形式



需求调研得到需求规约

根据需求规约分析建模得到需求分析规约

功能、数据、行为 

### 两个阶段

需求调研

需求分析

### 七个action

## 5.2 建立根基

#### 启动

- 多数项目都是当确定了商业要求或者发现了潜在的新市场，新服务的时候才开始。
- 业务领域的利益相关者定义业务用例
- 建立对问题、谁需要解决方案，期待解决方案的性质、项目利益相关者和开发人员之间达成初步的交流合作效果
- 根据甲方的需求来确定


### 5.2.1 确定利益相关者

确认利益相关者：业务运行管理人员、产品管理人员、市场销售人员、内部和外部客户、最终用户、顾问、产品工程师、软件工程师、支持和维护工程师以及其他人员

需求工程师应该创建一个人员列表，列出那些有助于诱导出需求的人员。最初的人员列表将随着接触的利益相关者人数增多而增加。

#### 实例

5.3.1中的safehome的启动阶段


- **利益相关者：软件团队成员、软件工程师、市场销售人员、产品工程代表，甲方，数据库提供商，潜在的硬件提供商，传感器的提供商**



- 问题：住宅管理系统中的安全功能。防止和识别各种不希望出现的情况提供保护，如非法入侵、火灾、漏水、一氧化碳浓度超标使用无线传感器监控每种情况，户主可以编程控制，并且在发现情况的时候自动电话联系监控部门。



- 谁需要解决方案：住宅用户，户主



- 期待解决方案的性质：

- 期望需求：

- - 人机交互的容易醒、整体的运行正确性和可靠性以及软件安装的简易性
  - 通过网络访问所有功能
  - 确保外人不能非法侵入系统，使系统失效、抢劫


功能细节：

- 能不能自动关闭，要不要加入物联网
- 如何处理异常情况
- control panel：提醒方式，电话，通知，物联网


### 5.2.2 识别多重观点

从多个角度收集信息时，所形成的需求可能存在不一致或者互相矛盾。需求工程师的工作就是把所有的利益相关者提供的信息（包括不一致或是矛盾的需求）分类

##### 将利益相关者提供的信息整理分类

分类的方法应该便于决策制定者为系统选择一个内部一直的需求集合

### 5.2.3 协同合作

项目领导者对删减哪些需求做出决策 

### 5.2.4 首次提问

- 谁是项目的最初请求者

- 谁将使用该解决方案

- 成功的解决方案将带来什么样的经济收益

- 对于解决方案还有其他资源吗 


## 5.3 导出==#掌握safehome的例子==

需求工程的定义：

致力于不断理解需求的大量任务和技术。开始于沟通活动并且持续到建模活动

==当客户给出了safehome简单的需求，我们要从对象entity的角度，从功能function的角度，从约束和限制的角度分别分析，从性能performance的角度，对于每个参与调研的人员，每个stakeholder都要分析，得到初步的需求规约==

例子
• 确认利益相关者：业务运行管理人员、产品管理人员、市场销售人员、内部和外部客户、最终用户、顾问、产品工程师、软件工程师、支持和维护工程师以及其他人员
• 利益相关者：软件团队成员、软件工程师、市场销售人员、产品工程代表，甲方，数据库提供商，潜在的硬件提供商，传感器的提供商
• 问题：住宅管理系统中的安全功能。防止和识别各种不希望出现的情况提供保护，如非法入侵、火灾、漏水、一氧化碳浓度超标使用无线传感器监控每种情况，户主可以编程控制，并且在发现情况的时候自动电话联系监控部门。
• 谁需要解决方案：住宅用户，户主
• 期待解决方案的性质：
• 期望需求：

步骤

1. 找到对象（名词或词组）：传感器，电话号码，控制面板，报警器
2. 找到功能（动词）：报警等等
3. 找限制：只能如数字信号，多久无响应报警
4. 找性能：

```
1. 人机交互的容易性、整体的运行正确性和可靠性以及软件安装的简易性
2. 通过网络访问所有功能
3. 确保外人不能非法侵入系统，使系统失效、抢劫
```

##### 范围问题Problems of scope 

系统边界、客户用户的说明带有不必要的技术细节，这些细节导致混淆

- 外部接口：可配置的内容
- 内部功能：监控功能
  - 如果漏水了，控制面板上报警，发出声音。
  - 不同的危险有不同的声音。
  - 30秒没有人开门来控制的话再报警


##### 理解问题Problems of understanding 

详细调研

- 提醒功能
  - 烟雾浓度，提醒声音
- 监控功能
  - 监控的后续处理
    - 电话，通知，物联网


##### 易变问题Problems of volatility

需求随时间变化，需求工程师必须以有组织的方式展开需求收集活动

##### 对象objects

名词或者名词词组，潜在类。entity，potential class

名词包含属性（系统需要处理的原始数据）

传感器、电话号码、警报、控制面板、门窗传感器、显示器、计算机、电话

##### 功能functions

动词

配置系统、设置警报器、检测传感器、电话拨号、控制面板编程、读写显示器、异常处理

##### 限制constrains

成本、规模、大小、业务规则

不能用脉冲信号，只能用数字信号，特定传感器，操作系统，有线和无线结合，成本约束 

##### 性能performance

速度，精度



## 5.4 开发用例

本质上，用例讲述了能表达主体场景的故事：最终用户（扮演多种可能角色中的一个）如何在一特定的的环境下和系统交互。

#### 确定“参与者”

- 参与者是在将要说明的功能和行为环境内使用系统或者产品的各类人员。
- 参与者代表了系统运行时候人（或设备）所扮演的角色
- 参与者是任何与系统或产品通信的事物，且对系统本身而言参与者是外部的。

参与者和最终用户并非一回事，典型的用户可能在使用系统时扮演了许多不同的角色，而参与者表示了一类外部实体，在用例中仅仅扮演一种角色。

例如一个机床操作员可以分解为：程序员、测试员、监控员和故障检修员

#### 实例

safehome中四个重要参与者：

- 房主（用户）
- 配置管理人员（很可能就是房主，扮演不同的角色）
- 传感器（附属于系统的设备）
- 检测子系统（检测safehome房间安全功能的中央站）

##### 对象确定objects

名词或者名词词组：实体、潜在类（entity，potential class）

名词包含属性（系统需要处理的原始数据），选择我们需要的属性来构造出我们的实体

传感器、电话号码、警报、控制面板、门窗传感器、显示器、计算机、电话

##### 功能确定functions

动词和动词词组代表实体之间的关系

配置系统、设置警报器、检测传感器、电话拨号、控制面板编程、读写显示器、异常处理 

##### 限制constrains

用来描述关系的属性

成本、规模、大小、业务规则

不能用脉冲信号，只能用数字信号，特定传感器，操作系统，有线和无线结合，成本约束

##### 性能performance

速度，精度

##### 输出：初步的需求规约草稿draft

use case diagram 

## 5.5 构建需求模型

#### 精化

分析建模阶段

* 功能：actiity
* 数据：ERD，Class Diagram
* 行为：sequence

分为过程和面向对象（在建模中怎么区分）

从不同角度理解需求

精化是由一系列的用户场景建模和求精任务驱动的，这些场景描述了如何让最终用户和其他参与者进行交互

解析每个用户场景以便提取分析类----最终用户可见的业务域实体

定义每个分析类的属性，确定每个类需要的服务，确定类之间的关联和协作关系，完成各种补充图

## 5.6 协商

把需求的优先级确定，按照优先级讨论冲突，使用迭代的方法给需求排序 

#### 形成规约

需求规约和需求分析规约

## 5.7 确认需求

对需求的工程的工作产品进行质量评估。已无歧义的说明了所有系统需求，检测出不一致、疏忽和错误并得到纠正；工作产品符合为过程、项目和产品建立的标准

**technical review正式技术评审是最主要的需求确认机制**。

* 确认需求的评审小组包括软件工程师、客户、用户和其他利益相关者。
* 检查系统规格说明，查找内容或解释上的错误，以及可能需要进一步解释澄清的地方，丢失的恶信息，不一致性或者冲突的需求

#### 需求管理

基于计算机的系统其需求会变更，而且变更的要求贯穿于系统的整个生存期。

需求管理时用于帮助项目组在项目进展中表示、控制和跟踪需求以及需求变更的一组活动

需求规约和需求分析规约

概要设计阶段，对需求还有变更

 

# 第六章 建模

从不同的视角检验需求

* 基于场景的建模
  * 从用户角度表现系统
  * 出自各种系统“参与者”观点的需求
* 数据信息建模
  * 提出信息空间
  * 描述了软件要加工的数据对象
  * 描述了数据对象间的关系
* 面向类的模型
  * 基于类的建模：定义了对象、属性和关系
  * 通过类的写作获得系统需求
* 面向流程的模型
  * 表示系统的功能元素并且描述当功能元素在系统运行时候进行怎样的数据变换的模型
* 行为模型
  * 描述了系统状态、类和事件在这些类上的影响
  * 描述了如何将软件行为看作是外部“时间”后续的模型

分析建模从多个维度表现需求，增加了查明UC哦呜、消除不一致、发现遗漏的几率



use case diagram干什么用的

sequence diagram从哪里来的

state diagram是干什么用的

## 6.1==#掌握==

### 6.1.4 需求建模的方法

#### 第一种建模：结构化的分析建模==#掌握==

一种考虑 **数据和处理** 的需求建模方法，其中处理将数据作为独立实体加以转换

数据对象建模定义了对象的属性和关系，操作数据对象的处理建模应该表明当数据对象在系统内流动时处理如何转换数据

##### 流模式 flow

以DD数据字典为中心

- 数据在系统中流动的组织方式
- 和接口紧密相关

ERD：数据建模

结果：数据对象的描述

DFD：功能建模

结果：加工规约

STD：状态（行为）建模

结果：控制规约

#### 第二种建模：面向对象的分析建模

这种方法关注于定义类和影响客户需求的类之间的写作方式。

UML的统一过程主要是面向对象的分析方法

#### 每个元素表示源自不同观点的问题

## 6.2 基于场景建模

表示用户如何与系统和使用软件时出现的特定活动序列进行交互

UML需求建模从开发用例、活动图和泳道图形式的场景开始

如：

用例

用户故事

safehome例子P136

## 6.3 补充用例的UML模型

### 6.3.1 开发活动图

两端为半圆形的矩形宝石一个特定的系统功能

箭头表示通过系统的流

菱形表示判断分支

实心水平线意味着并行发生的活动

### 6.3.2 泳道图

表示用例所描述的活动六

指示哪个参与者或分析类是由活动矩形所描述的活动来负责

职责由纵向分割的并行条表示

## 6.4 数据建模

实体关系图

### 6.4.1 数据对象

数据对象：软件理解的符合信息表示。

符合信息指具有若干不同的特征或属性的事物

#### 数据对象和面向对象类

##### 对数据项的处理方式不同

数据对象定义了一个符合的数据项，合并一组独立的数据项（属性）并命名（数据对象名）

类封装了数据属性，对这些属性定义数据的操作进行合并

##### 类是面向对象工程方法一部分

类定义暗示了一个全面的基础设施，是面向对象软件工程方法的一部分

##### 类之间的消息机制

类之间通过消息通信，可以按照层次关系组织，并为某各类的一个实例对象提供继承特性

### 6.4.2 数据属性

- 为数据对象的实例命名
- 描述这个实例
- 建立对另一个表中的另一个实例的引用

## 6.5 基于类的元素建模

基于类的分析模型的元素包括类和对象、属性、操作、类的职责写作者模型（CRC）、协作图和包

- 系统操作的对象
- 应用在这些对象间影响操作
- 对象之间关系的操作
- 类之间发生的协作

如：

类图

协作图

### 6.5.1 识别分析类

第一次出现的名词：都是潜在的对象，可以进行分类，判断对象是否有如下特征

* 保留信息：记录潜在类的信息才能保证正常工作
* 所需服务：潜在类具有一组可以确认的操作，这组操作能用某种方式改变类的属性值
* 多个属性：单个属性的潜在对象可以作为其他类的属性
* 公共属性
* 公共操作
* 必要需求

第一次出现的动词

### 6.5.2 描述属性

什么数据项能够在当前问题环境内完整的定义这个类？

找出要做的事情，拆分为多个基础信息作为类

如果有超过一个项和某个类相关联，就应该避免吧这个项定义为属性

### 6.5.4 CRC类-职责-协作者建模

识别和组织系统或者产品需求相关的类

#### 类

##### 实体类

模型或业务类，从问题说明中直接提取出来的，这些类一般代表保存在数据库中和贯穿应用程序的事物

##### 边界类

创建用户可见的在使用软件时候交互的接口，例如屏幕或者打印的报表

##### 职责

管理实体对象对用户的表示方式

##### 控制类

自始至终管理“工作单元”

* 实体类的创建或者更新
* 边界类从实体对象获取信息后的实例化
* 对相机和之间的复杂通信
* 对象之间或者用户和应用系统之间交换数据的确认

#### 职责

类相关的属性和操作，类所知道或者能做的任何事

#### 协作 

提供某个职责所需要信息的类，协作者意味着某个信息请求或者动作请求

### 6.5.5 关联和依赖

#### 关联

两个分析类相互联系

一对多，在1的一边写1，多的一边写0..*或者1..\*

#### 依赖

依赖是一个构造性定义的<\<stereotype\>>

例子：

一个摄影机对象想一个展示面板提供视频图像

这两个对象之间存在依赖关系

在监事用例中，建模这知道必须提供特定的密码才能观察看指定摄像机的位置

让camera请求密码，然后在获得display window的允许以后显示视频

### 6.5.3 定义操作

* 增删改查选择格式化
* 执行计算
* 请求某个对象
* 监视某个对象发生某个控制事件的操作

## 6.4 行为元素

描述了外部事件如何改变系统或驻留在系统中的状态

如：

状态图

顺序图

## 6.5 面向流的元素

表示信息转换的系统

描述了数据对象在流过各种系统功能时是如何转换的

如：

数据流图

数据模型

## ERD

属性是构成数据字典的最小单位，接口设计的依据

设计数据库的依据

- 名词、名词词组作为实体。分析属性，系统需要的属性。不同类型的同一实体系统关注的属性是不相同的
- 动词、动词词组作为实体之间的关联关系。找动词附加的属性，需要是系统关注的内容
- 实体之间的三种关系
  - 一对一
  - 一对多
  - 多对多
- 反复评审

### 小结

场景建模：用例是主要的建模元素，活动图和泳道图补充说明

数据建模：数据对象、属性、对象之间的关系

CRC索引可以用来定义类之间的关系，UML建模方法可以定义类之间层次、关系、关联、聚合和依赖的关系

# 第七章 需求建模：流程、行为、模式

这里的每种模型都是补充用例、数据模型和基于类的模型

面向流程建模提供过一种如何利用处理功能转换数据对象的表示方法

行为建模：描述了系统以及类的状态，以及时间对这些类的影响

模式的建模：利用现有的知识领域使得需求分析更容易

## 7.1 需求建模策略

#### 结构化分析

考虑数据和处理的分析建模方法被称作结构化分析

数据作为独立的实体转换。

数据对象模型的方式定义了它们属性和关系。

操作数据对象的建模过程表明了当数据对象通过系统的时候如何转换。

#### 面向对象分析

关注定义类以及影响客户需求的类之间的写作方式

#### ==系统工程建模system engineering==

系统元素：

- 硬件工程
- 软件工程
- 数据工程
- 网络工程
- 人力工程

任何系统都可以抽象为

- 输入处理
- 输出处理
- 用户界面
- 维护和自测试
- 处理和控制功能

##### 抽象的主要目的

区分硬件工程和软件工程

##### 系统建模的目的

区分硬件要完成的和软件要完成的功能

##### 传送带例子的系统功能建模

- 软件结构：包括和硬件的接口
- 硬件部分
- 箭头描述了数据的整体流动过程



软件部分还可以再分：

- 模块专门完成某一种功能，实现某一种接口，和某一种硬件进行交互


## 7.2 面向数据建模（功能建模）

DFD图不是UML正式组成部分，但是可以补充UML图，并提供对系统需求和流程的补充认识

DFD图采取了系统的输入-处理-输出观点，流入软件的数据对象，经由处理元素变换，最后以结果数据对象的行驶流出软件

- 带标记的箭头表示数据对象
- 圆圈表示转换

第一个数据流模型表示整个系统，随后的数据流图改进环境图

结果：数据流图

面向流程建模

### 7.2.1 创建数据流模型 DFD

当把DFD逐步细化时，完成了系统的功能分解

在结构化分析中，数据建模是核心建模活动

##### 指导原则

* 第0层数据流图将软件或者系统描述为一个泡泡
* 仔细标记主要的输入输出
* 通过把选定的处理、数据对象和数据存储分离为下一层表示二开始精化的过程
* 使用有意义的名称
* 从一层转到另一层保持信息连续性
* 一次精化一个泡泡，可能会有一种趋势使得数据流图过于复杂



圆圈：transform：理解为功能（高内聚）转换

线段：input data：数据字典，数据对象或者数据类型的层次

方形：外部系统，硬件

双横线：数据存储data store：数据库或者文件系统

##### 建模原则

- 信息流平衡：输入输出的数量，每一个dfd要相同
- 达到功能的独立性，一个bubble只完成一个功能
- 达到箭头上的数据组织比较单一，不能再细分
  - DF(0)->DF(1)->DF(2)...

#####  DFD(0)

硬件和软件剥离出来，软件看为一个功能，把硬件尽量剥离出来

**从较高层面抽象数据流动**

* 一个箭头指向软件系统
  * 输入：不能成为数据字典，数据太复杂，有很多种命令
  * 有各种数据组织形式
  * 用户通过control panel启动或者关闭、配置系统（类型和阈值）


#####  DFD(1)

**从数据流的角度理解需求规约** 

对描述环境层泡泡的用例叙述采用语法解析

以软件部分的需求规约中的文字描述中的动词和名词词组分开

###### **语义扫描**

根据动词和名词表示的层次提炼出来

名词和名词词组：箭头（数据），方形（外部系统）

动词和动词词组：圆圈（功能）

建模需要使用系统中的流动数据 

问题：需求功能涉及到硬件了，但是上述建模只涉及软件建模

答案：系统的数据、功能、行为状态建模是包含硬件和软件的 

##### 两种不同分类的系统

- 纯软件系统
- 系统工程：由多种工程构成的复杂系统
  - 建模之前要进行系统建模，进行软硬件的分离


#####  DFD(2)

对DFD进一步细化，直到每个泡泡只执行单一的功能，该功能很容易的称为一个程序构建

### 7.2.3 控制规格说明 CSPEC

control specification cspec（在被引用的层次上）使用**两种不同的方式表现系统的行为**

**CSPEC包含一个状态图，该图是行为的序列说明，也可能包括程序激活表即行为的组合说明**

#### 控制规格说明

事件发生要调用的功能

状态发生迁移时的action列表

#### 状态图

##### 定义

状态图表示了当系统在这个层次上定义的多个状态之间来回移动的时候，系统如何对事件作出相应。

当发生某事件的时候，系统从一个状态转移到另一个状态，并调用处理当前状态的一些方法和模块

##### 与设计环节的关系

为主程序结构设计提供依据

系统级别的通常会依赖状态图

跟状态有关的子功能的设计和系统的设计依据

==类和方法设计的参考依据==

##### ==考试要画状态图、类定义==

每个类都有一个状态图

##### 状态图基本元素

事件、状态、行动

* 事件发生以后调动相关的功能来处理
* 到另一个状态以后等待采取行动
* 一个起始状态，多个终止状态

状态图中可有多个状态框，每个状态框中有两格：上格放置名称，下格说明处于该状态时，系统或对象要做的工作（**Activity**）状态之间的过渡事件**(Event)**，对应对象的操作。

事件有可能在特定的条件下发生，在**UML**中这样的条件称为守护条件（**Guard Condition**）。

发生事件时的处理称为行动（**Action**）。

从一个状态到另一个状态之间的连线称为迁移（**Transitions**）。

一个对象也可能包含有更多的详细情形或子状态，这就引出有嵌套的状态图。 

**事件发生时候一个状态转换为另一个状态，因为要调用另一个状态的方法**

##### 例子

###### 订单状态

开始

初始化

加物品

统计订单，金额和数量

删除物品

结束处理订单，调用下列方法

支付状态P1（其他类中的方法，订单调用的关系）自反：支付错误，内部处理，Pn其他类内部的方法

运输状态（其他类中的方法，订单调用的关系）自反：运输错误，内部处理

###### 方法

初始化

增加物品

统计金额

删除物品

结束处理（外部接口的桥梁）

四个内部调用的方法

一个外部调用的方法

#### PAT处理激活表

PAT表示了当有事件发生时，会引入流程模型中哪个泡泡

PAT是行为表达的一种非常不同的模式，它表示了在状态图中处理环境中包含的信息，不包括的状态，因此这张表指出了当有事件发生时，会引入流程模型中的哪个处理。处理激活表可以作为设计人员的指南，必须建立在这一级别山更可以执行的处理控制

### 7.2.4 处理规格说明pspec

（process specification）功能的逻辑描述

描述出现在求精过程中最终层次所有流程模型的处理。处理规格说明的内容可以包括叙述性正文、处理算法的程序设计语言的描述（PLD）、数学方程、表或者uml活动图。

每一个泡泡都要有pspec

大多都会映射为模块

密码处理转换处理了所有的密码问题，密码过程接受了四个数字密码，首先和主要的密码存储来比对，如果正确就传输一个数据和状态展现。如果错误，就和二级密码存储比对。可能会被赋，过程同上。

如果这个阶段还有其他算法，那么算法设计了语言代表桐乡要作为pspec的一部分。很多人认为PDL版本应该推迟知道部件设计完成

**通过DFD图的映射设计可以转换为模块结构图**

在实现的时候，根据功能逻辑描述pspec，画出流程图以后方便实现

==在dfd图中每个pop都有对应的pspec==

==Process password 的加工规约==

### 7.2.0 功能建模结果

功能建模完成以后得到dfd图以及每一个bubble的加工规约（pspec）

dfd2（最终版本）中的每一个箭头代表数据组织方式

#### 数据字典

最后一层dfd图中所有箭头上的数据组织方式

##### 数据组织方式

telephone number的数据组织方法

箭头上的数据信息大多数来自于不同entity的属性，以不同的方式组织起来的数据字典

数据的组织来自实体的属性

#### 练习

order类

通过画状态图，看订单整个的处理流程

状态、事件、动作

## 7.3 生成行为模型

将静态元素转为系统或者产品的动态行为，可以通过吧系统行为表示成一个特定的事件和时间函数

### 7.3.1 识别用例事件

只要系统和参与者之间交换了信息就发生了事件

一旦确定了所有事件，事件被分到涉及的对象中

* 对象生成事件
* 识别已经在其他地方发生的事件

### 7.2.3 状态表现

在行为建模的场合下，必须考虑两种不同的状态描述

* 系统执行功能时每个类的状态
* 系统执行其功能时能从外部观察到的系统状态

#### 被动状态

被动状态只是某个对象所有属性当前的状态

例如player当前的position

#### 主动状态

对象进行持续变换或者处理时候当前的状态

例如player的移动、休息状态

#### 两种不同的行为表现形式

##### 分析类的状态图

显示一个类如何改变基于外部事件的状态

UML状态图，为每个类呈现了主动状态和导致这些主动状态变化的事件（触发器）

* 箭头表示某个对象从主动状态转移到另一个主动状态
* 箭头标注体现了触发状态转移的事件

###### 守卫

守卫是为了保证状态发生而必须满足的一个布尔条件

转移的守卫通常依赖于某个对象的一个或者多个属性值。守卫依赖于对象的被动状态

###### 动作和状态转移

动作与状态转移同时发生的或者它作为状态转移的结果，而且通常动作包含对象的一个或者多个操作

例如

事件：输入密码

动作：validatePassword()

##### 顺序图

以时间函数的行驶显示软件的行为

表明事件如何引发从一个对象到另一个对象

表现了导致行为从一个类流到另一个类的关键类和事件

### 小结

数据流对象处理功能转换

面向流程建模：关注数据流对象，从结构化分析进行推导

面向流建模：使用了数据流图建模符号描述了当数据对象移动通过一个系统时，如何将输入转化为输出，由一个处理的规格说明或者叙述来描述转换数据的每个软件功能

控制流是说明时间如何影响系统行为的一种图示

行为建模：描述了动态的行为。行为建模采用基于场景、面向流程、基于类的输入，从而把分析类和系统的状态作为一个整体来表达，常使用状态图和顺序图

* 识别状态
* 定义引起类（或者系统）
* 由一个状态转换到另一个状态的事件
* 完成转换后发生的活动

# 第八章 设计建模

设计模型提供了软件体系结构、数据结构、接口和构建的细节

首先，必须表示系统或者产品的体系结构

其次，为各类接口建模，这些接口在软件和最终用户，软件和其他系统与设备以及软件和自身组成的构建之间起到的联系作用

最后，设计构成系统的软件构建。每个视图表现了不同的设计活动。

## 8.1 软件工程中的设计

软件设计是建模活动中最后一个软件工程活动，接着就进入构造阶段（代码生成和测试）

#### 设计输入

需求模型

* 基于场景的元素
  * 用例文本
  * 用例图
  * 活动图
  * 泳道图
* 基于类的元素
  * 类图
  * 分析包
  * CRC模型
  * 协作图
* 面向流的元素
  * 数据流图
  * 控制流图
  * 处理叙述
* 行为元素
  * 状态图
  * 顺序图

#### 设计输出

设计模型

* 数据或者类的设计
  * 将类模型转化为设计类的实现以及软件实现所要求的数据结构
  * CRC图中定义的对象和关系，类属性和其他表示法刻画的详细数据内容为数据设计活动提供了基础
* 体系结构设计
  * 定义了软件的主要构造元素之间的关系
  * 用于达到系统所定义需求的体系结构风格和设计模式以及影响体系结构实现方式的约束
  * 可以从需求模型导出
* 接口设计
  * 描述了软件和写作系统之间，软件和使用人员之间如何通信
  * 意味着信息流（如数据和控制）和特定的行为类型
  * 场景和行为模型为接口提供了所需要的大量信息
  * **data flow图：箭头（数据字典）与接口设计有直接关系**
    * DFD图经过设计变成模块之间的调用存储关系
  * **状态图：一个状态到另一个状态需要事件来触发，调用方法来解决，调用的方法就是接口**
* 构件级设计
  * 将软件体系结构的构造元素变为软件构建的过程性的描述
  * 从基于类的模型、流模型和行为模型获得的信息作为构建设计的基础
  * DFD图经过设计变成模块之间的调用存储关系

##### 数据设计

数据库设计

数据仓库设计

数据标记设计



## 8.2 设计过程

### 8.2.1 软件质量指导原则和属性

#### 指导原则

1. 设计应展现出这样一种结构
   1. 已经使用可识别的体系结构风格或者模式创建
   2. 由展示出良好的设计特征的构建构成
   3. 能够以演化的方式实现，从而便于实现和测试
2. 设计应该模块化，应该讲软件逻辑的划分为元素或者子系统
3. 设计应该包含数据、体系结构、接口和构件的清晰表示
4. 设计应该导出数据结构，这些数据结构适用于要实现的类，并可以从是别的数据模式中提取
5. 设计应导出显示独立功能特征的构件
6. 设计应该导出接口，这些接口降低了构建之间以及与外部环境连接的复杂性
7. 设计的导出应根据软件需求分析过程中获取的信息采用可重复的方法进行
8. 应使用能够有效传达意义的表示方法来表达设计

#### 评估设计质量——技术评审

设计阶段展开一系列技术评审（technical review，TR）来评估质量。

会议前：所有成员收到设计工作产品的拷贝，寻找错误、一楼或者含糊不清的地方

会议后：确定在设计工作产品能够被认可为最终设计模型的一部分之前，是否还需要进一步行动

#### 质量属性

##### 功能性（functionality）

通过评估程序的特征集和能力、所提交功能的通用性以及整个系统的安全性来评估

##### 易用性（usability）

易用性通过考虑人员因素、整体美感、一致性和文档来评估

##### 可靠性（reliability）

通过测量故障的频率和严重性、输出结果的精确性、平均故障时间（Mean-Time-To-Failure，MTTF）、故障恢复恩能够离和程序可预见性来评估

##### 性能（performance）

通过考虑处理速度、相应时间、资源消耗、吞吐量和效率来度量

##### 可支持性（supportability）

###### 可维护性

- 可扩展性：扩展程序的能力
- 适应性
- 耐用性

还包括测试性、兼容性、可配置型（组织和控制软件配置元素的能力）、系统安装的简易型和问题定位的容易性

#### P157通用设计任务集

## 8.3 设计概念

### 8.3.1 抽象

高抽象级别：

使用问题所处环境的语言以概括性的属于描述解决方案

低抽象级别：

解决方案以一种能够直接实现的方式得到陈述

### 8.3.2 体系结构

### 8.3.3 模式

设计模式描述了在某个特定场景与可能影响模式应用和使用方式的“影响力”中解决某个特定的设计问题的设计结构

* 模式是否适用于当前的工作
* 模式是否能够复用
* 模式能否用于指导开发一个类似的，但是功能结构不同的模式

### 8.3.12 设计类

需求模型定义了一组分析类，每一个分析类都描述问题域中的某些元素，这些元素关注用户可见问题方面。分析类的抽象级相对比较高

设计模式演化时，定义一组设计类：

* 通过提供设计细节精化分析类，这些设计细节将促成类的实现
* 实现支持业务解决方案的软件基础设施

#### 五种设计类

每一种表示了设计体系结构的不同层次

##### 用户接口类

人-机交互所必须的所有抽象

HCI出现在隐喻环境，接口设计类可能是这种隐喻元素的可视化表示

##### 业务域类

早期定义的分析类的精化，识别了实现某些业务域元素必须的属性和方法

##### 过程类

##### 持久类

##### 系统类

#### 四个特征

##### 完整性与充分性

##### 原始性

##### 高内聚性

内聚的设计类有小的、集中的职责集合，专注于使用属性和方法来实现职责。只要每个类中的所有方法都只关注某功能的相关属性。

##### 低耦合性

设计类之间的协作保持在一个可以接受的最小范围内，只向周边类发送消息

#### 接口设计

* 用户界面
* 和其他系统，设备，网络或者其他信息生成的或使用者的外部接口
  * 关于发送和接收信息的实体的确定信息。信息需要在系统工程中收集，开始接口设计以后要检查这些信息
* **各种设计构建之间的内部接口**，这些接口设计元素能够使软件进行外部通信，还能使软件体系结构的构建之间进行通信和协作
  * 和构件设计紧密相关。分析类的设计实现表示了所有操作和消息传递模式，使得不同类的操作之间能够进行通信和协作。每个消息的设计必须提供必不可少的信息传递和被请求操作的特定功能需求。**如果选择输入处理输出设计方法，每个软件构建接口就基于数据流表示和处理过程说明中描述的功能进行设计**

接口是一组描述类的部分行为的操作，并提供了那些类操作的访问方法

例子

SafeHome安全功能使用控制面板，控制面板允许户主控制安全功能的某些方面，控制面板的功能可能会通过PDA或者移动电话实现

ControlPanel类提供了键盘相关的行为，因此必须实现操作readKeyStroke()

decodeKey()

在图中使用一个带有标识且用一条线和类相连的小圆圈表示，定义接口时，并没有实现键盘行为所必须的属性和操作集合

或者表示为<<interface>>构造型



# 第九章 体系结构设计

开始于数据设计

### 9.3.1 体系结构风格的分类

#### 以数据为中心的体系结构

经常访问数据库，进行增删改查

黑板构建负责协调信息在客户之间的传递

#### 数据流体系结构

#### 调用和返回体系结构

##### 主程序子程序体系结构

其中一种子风格

这种传统的程序结构将功能分解成一个控制层次

其中主程序调用一组程序构建，这些程序构建由去调用其他构建

## 9.6 使用数据流进行体系结构映射

从信息流到体系结构的转换：

建立信息流的类型

标注流的边界

将DFD映射到程序结构

定义控制层级

使用设计度量和启发式精化产生的结构

求精并细化体系结构描述

### 9.6.1 变换映射

分析模型有一个元素是描述安全功能中信息流的一组数据流图

##### 评审基本系统模型

0层

##### 评审和精华软件数据流图

检查第二层监控胡灿干起的DFD

导出第三层数据流图：每个变换都展示了相对高的内聚性

##### 确定DFD是否含有变化流或者事务流

##### 通过确定输入和输出流的边界，分离出变换中心

可以调整边界的位置

##### 完成第一级分解

使用这个映射导出的程序体系结构导致了自顶向下控制分布

顶层构件：完成决策制定

底层构件：完成大多数输入、计算和输出工作

中间构件：完成一部分控制和适度的任务

* 主控制器位于程序结构的顶端
* 输入控制器
* 条件控制器
* 输出控制器

##### 完成二级分解

将DFD中的每个泡泡映射到体系结构中相应的模块

* 从变换中心的边界开始，沿输入路径和输出路径向外，将变换依次映射到软件结构的从属层中
* 输入输出流一侧的映射方法相同
* 变换中心映射有所不同，每个数据转换或者计算变换都被映射成为一个下级模块

为每个构建提供简要的处理说明

* 规格说明是为了需求建模过程中建立数据变换所开发的
* 简要描述
  * 说明描述构建接口
  * 内部数据结构
  * 功能说明
  * 限制和特殊功能

##### 精化第一次迭代得到的体系结构

explode：分解

implode：结合

## 分析设计回顾

### use case diagram

面向对象中分析和设计的划分不清晰

1. 帮助我们从产品的角度理解需求
2. 对于复杂系统测试的重要依据
3. 每一个use case和现在这个有什么关系，跟use case有什么关系，序列图中的动态交互来验证需要哪些类和功能构成
4. 分析的时候序列图是粗放的，设计的时候是详细细化



分析的时候每个类的属性只有简单的方法，属性的类型都可以没有，方法也不够完整

#### safehome的用例图

成功

异常

用户名

密码

验证码

对应四个序列图，因为返回的对象有所不同

登录的时候调用一个显示的类，对login的接口显示化，有一个模拟信号到物理信号的转换

输入处理检查

数据库处理类

显示功能处理类

==序列图直接用来验证use case产品功能的正确性==

==Use case中的功能动作根据序列图进行细化==

### 状态图

每个类都有状态图

细化：有什么事件，类内方法调用，类间方法调用

### 活动图

模块流程图

活动图可以描述类、方法的逻辑

类中的方法需要有非常详细的设计

没有属性只有方法的类

通用的类

显示出来等等

只有属性没有方法的类

### 流程图

需求调研

用例图

建模

分析建模

设计建模

尤其是每个类中的定义

依据类来设计数据库

### ==DFD到软件体系结构==

两种DFD的类型

==考试考大题==

软件体系结构是概要设计中的重要部分

architecture

#### DFD两种类型

##### 基于变化流的形式

transform

某一个流或者多个流经过bubble分析以后可以从多个流流出

incoming flow

变换中心

##### 基于事务流的形式

transaction

每一种流经过bubble分析以后只能沿着一个流出去

流入：

transaction

处理：

transaction center

输出：

action paths

在设计的时候DFD要分析类型，是变化类还是事务类

#### 变换流设计：

safehome系统最后一层的dfd图

1. 识别变化流和事务流
2. 划分边界

  ​把incoming flow 和transform center 和outgoing flow隔离出来

  ​通过一条线隔离

  ​基本原则，调用不能太深

3. 创建主控模块CM（得到初步的体系结构）

   SM1，SM2，SM3

   每一个模块对应一个pspec

   incoming flow映射到左边

   新输入的映射到叶子

   后输出的叶子在下面

4. 优化

   内爆：两个节点合并成一个，两个功能太简单并且内部还有很多调用

   外爆：一个节点爆成两个，加一个控制模块

   如果一直往下调用会影响最后的性能

每一条线都是call return

CM相当于Main主函数

一个分支的模块主要做输入流，一个模块主要跟处理有关，一个跟输出相关

应用子程序的接口设计就根据掉用户调用事务设计

控制模块和子应用模块的接口设计根据两个模块之间的关系设计

#### 事务流设计：

==期末考试：transaction mapping的图15分题目==

每一个action path又有变化流，又有事务流

a、b：transaction

d：transaction center

三个action path

增加一个transaction control

把transaction画在左边，先输入的放在下面

transaction映射到右边

事务中心下面增加三个控制模块，把action path添加到控制模块下面

#### 画图流程

主控模块

有三个模块，分成三个自控模块

最下面的分支增加三个控制模块

注意方块的部分是到数据库中读取数据，不需要画出来

因为是被动的输入，不是主动的输入，所以不考虑

删除不必要的控制模块

接口：

* 直接来自数据字典，作为数据流的同一个分支
* 以数据字典的设计为依据，从直接交互变为先传数据给控制模块，再间接交互：属于不同分支



对三个分支进行分析，看是事务流还是变化流

变化流，增加主控模块，对于incoming center outgoing 增加三个子控模块，只管理一个流的控制模块可以删去

d事务中心，action path有变化流和事务流

### 详细设计

针对每一个模块进行设计：尤其是叶子

限制条件，异常处理：密码位数不够，不是字母

输出项（被其他模块调用）

输入项（调用其他模块）

status初步类设计

activity diagram可以用于某个方法，某个类的逻辑设计

概要设计中初步的class diagram和status diagram为依据

类设计以状态图

接口以sequence diagram

一个use case对应一个或多个sequence diagram

# 面向对象分析和设计

## 面向对象开发过程

需求：use case图，得到需求规约

描述类的静态特性以及类之间的关系：类图

描述类的生命周期：状态图（类内方法调用，类间方法调用）

描述类内部的方法：活动图

描述类之间的消息协作：顺序图、协作图

开发完成后软件系统的组成：component图

## 面向对象建模

### 用例图

分析过程：

#### 确定参与者

可以通过提出系统要做什么?这样的问题完成

对上述这些已经确定的用例，还要进一步明确它们之间的优先次序

#### 确定用例

#### 描述用例

### Sequence diagram顺序图

(每个use case有对应序列图，一个或多个)

描述类之间的消息协作

对象: 时序图中对象使用矩形表示, 并且对象名称下有下划线. 将对象置于时序图的顶部说明在交互开始时对象就已经存在了. 如果对象的位置不在顶部, 表示对象是在交互的过程中被创建的.

生命线: 生命线是一条垂直的虚线. 表示时序图中的对象在一段生命周期内存在. 每个对象底部中心的位置都带有生命线.

消息: 两个对象之间的单路通信. 从发送方指向接收方. 在时序图中很少使用返回消息.

激活: 时序图可以描述对象的激活和钝化. 激活表示该对象被占用以完成某个任务. 钝化指对象处于空闲状态, 等待消息. 在 UML 中, 对象激活时将对象的生命线拓宽为矩形来表示的. 矩形称为计划条或控制期. 对象就是在激活条的顶部被激活的. 对象在完成自己的工作后被钝化.

对象的创建和销毁: 在时序图中, 对象的默认位置是在图的顶部. 这说明对象在交互开始之前就已经存在了. 如果对象是在交互过程中创建的, 那么就应该将对象放到中间部分. 如果要撤销一个对象, 在其生命线终止点处放置 “ X” 符号.

### Collaboration diagram协作图

协作图可看作类图和顺序图的交集。协作图建模对象或角色，以及它们彼此之间的顺序通信。要创建一个系统，组成系统的这些类的实例(对象)就需要彼此通信和交互，即它们之间需要协作。协作图就是用于描述系统的行为是如何由系统的成分相互协作实现的UML图。

协作图(也叫合作图)是一种交互图.时序图主要侧重于对象间消息传递在**时间上的先后关系**, 而协作图表达对象间的**交互过程及对象间的关联关系**。

### 类图

(类图主要是实体类，还有界面类、控制类、接口类等)

描述了类以及类之间的静态关系。

#### 类的关系

public在属性名前写+号

##### 关联

强依赖

单向关联：A类中有B类的对象为属性，在类之间写上相应的属性名

双向关联：A和B中都有对方的对象作为属性，在类之间双方都写上对方引用自己的属性名

关联类：一方有另一方的对象集合，在类之间被集合的一边上写1…n

多重性：

多重性的符号表示如下所示(默认值是1)：

​    ·  “O．．1”——表示O或者1。

​    ·  “O．．*”或“*”——表示0或者多个。

​    ·  “1．．*”——表示l或者多个。

​    ·  “3．．16”——表示3至16。

​    ．  “1，3，15”——表示或者l或者3或者15。

##### 聚集（聚合）

是关联关系的一种特例，表示整体与部分的关系

整体和部分之间是可以分离，有格子的生命周期

在代码层面和关联关系是一致的

只能从语义级别来区分

控制面板类与液晶屏类和键盘类的关系

图中用实心菱形表示

##### 组合

关联关系的一种特例

强聚合，同样体现整体与部分的关系，但是整体和部分不可分，整体的生命周期结束意味着部分的生命周期结束

代码层面和关联关系一致，只能从语义来区分

比如人和人的大脑

用实心菱形表示

菱形指向整体一边

##### 泛化（继承）

图中用实线+空心三角指向父类

##### 实现

虚线+空心三角

##### 依赖

图中用虚线和箭头表示

对象之间最弱的一种关联方式，是**临时性**的关联。代码中一般指由**局部变量、函数参数、返回值**建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。

**聚合关系是“has-a”关系，组合关系是“contains-a”关系；**聚合关系表示整体与部分的关系比较弱，而组合比较强；聚合关系中代表部分事物的对象与代表聚合事物的对象的生存期无关，一旦删除了聚合对象不一定就删除了代表部分事物的对象。组合中一旦删除了组合对象，同时也就删除了代表部分事物的对象。

##### 关系总结

首先最弱的就是依赖关系，一半是临时用到另一个类的对象，有几种形式，一个是函数的参数、返回值、局部变量等等形式。用虚线加箭头表示。稍微强一点的是关联关系，一般是持久的，体现在属性的行驶出现，有单向双向的关系，在关联关系的两端可以标注双方的角色和多重性的标记。用实现加箭头表示。关联关系中的一种特例是从语义区分的，就是聚合关系，一个类和另一个类是整体和部分的关系，用空心菱形表示。强聚合关系是组合关系，组合的整体和部分的生命周期是相同的，两者是不可分的，图中用实心菱形表示。除了这些关系还有继承和实现，区别是父类和接口，用三角形加实现或者虚线表示。

### 状态图

方框状态名称，箭头上是时间，圆圈代表终态和初态

状态图通过建立对象的**生存周期模型**来描述对象随时间变化的动态行为.

### 活动图

活动图的主要用途如下：    

​    ·  描述一个操作执行过程中(操作实现的实例化)所完成的工作(动作)，这是活动图最常见的用途。

​    ·  描述对象内部的工作。

​    ·  显示如何执行一组相关的动作，以及这些动作如何影响它们周围的对象。

​    ·  显示用例的实例是如何执行动作以及如何改变对象的状态。

·  说明一次业务活动中的角色、工作流、组织和对象是如何工作的。

### 组件图（不懂）

组件图中可以表示各个组件之间的编译器和运行时的依赖关系

### 部署图（不懂）

## 数据库设计

在关系模型中没有“泛化”的概念，所以对“泛化”关系要根据实际情况选择转换的方法。比较常用的是称为“一类对一关系”转换方法，即把存在泛化关系类图中的一个类转换为关系模式中的一个关系。当然，在转换时要**在子类所转换的关系中添增父类的关键属性**。在如图所示的类图中，“专科生”、“本科生”和“研究生”两个类与“学生”类之间存在着泛化关系。

将图所示的类图转换为对应的如下三个关系。但是，在“专科生”、“本科生”和“研究生”3个关系中添增了“学号”作为与“学生”关系的关联。

​    学生(学号，姓名，性别，出生年月，家庭住址，联系电话)

​    专科生(学号，所属院系，所学专业，班级)

​    本科生(学号，所属院系，所学专业，班级)

​    研究生(学号，所学专业，研究方向，导师)

## 系统设计

1）软件平台设计

软件平台是系统开发和运行的环境。图书管理系统的开发和运行环境如下：

·  操作系统——操作系统是计算机系统中最重要的系统软件。图书管理系统可以运行在Windows 7／8／等桌面操作系统上。

·  支撑软件——支撑软件是协助人们开发和维护软件的工具和环境软件。数据库系统、集成开发环境等都属于支撑型软件，例如，Delphi、Oracle、Java等。图书管理系统使用的DBMS是Access 2003，数据库中间件是JDBC。

·  CASE平台——采用CASE开发环境可保证系统开发质量，提高开发效率，保证文档的一致性。图书管理系统的分析、设计实现和部署模型是在Rose 2003建模环境下创建的，清晰地表达了在不同的开发阶段的系统模型。

2）系统结构设计

​    结构设计是把软件分解成为多个子系统，并确定出由各子系统及其接口构成的软件系统结构。子系统是对软件分解的一种中间形式，也是组织和描述软件的一种方法。由多个子系统构成系统软件，每一个子系统又包括多个用例设计、设计类和接口。结构设计具体要做的工作是将系统划分成相对独立、功能相对完整的子系统(包)，将系统模型中的元素划分到不同的包中，说明在什么地方定义包，各个包之间的依赖性和主要通信机制。从而得到尽可能简单和清晰的结构，各部分之间的依赖尽可能的少，并尽量减少双向的依赖关系。

 3）详细设计与界面设计

​    详细设计是对软件结构中确定出的各个子系统内部的设计，需要分析和确定每一个子系统中的用例设计、设计类和接口。详细设计还要描述每个类的细节，并用动态模型描述类的实例在具体环境中的行为。

​    界面设计是对人和外部系统与系统之间交互界面的设计，包括输入界面、输出界面和输入／输出界面的设计。另外，界面设计还涉及到人机交互方式、人机交互流程、输入输出设备和媒体等内容。

  4）数据库设计

数据库是系统存储和管理数据的主要技术手段，数据库设计的任务是根据给定的系统应用需求和系统环境，设计出合理的数据库结构。数据库设计可分为概念设计、逻辑设计和物理设计3个阶段。用UML进行数据库设计的主要思想，是利用UML的扩展机制定义一些版型，用于表示与数据库相关的一些概念。Rose 2003提供了对数据库设计的支持，所设计的模型可以直接生成具体数据库中的表、触发器、存储过程等。

### 详细设计

#### 设计类图

在用例的基础上确定概念类，如果用例的功能比较简单，可以用一个设计类来实现三个概念类的功能

#### 顺序图

为实现用例的功能，每个用例要实现的功能要通过用例中各个类的对象的操作的相互协作完成，这就要在顺序图或协作图中映各个对象之间的消息调用过程。

#### 属性和方法设计

详细的设计所识别出来的每一个设计类

属性设计应该注意的问题是：一要补充属性分析时没有考虑到的属性，确定属性的全部内容，其中包括属性名、可视性、范围、类型、初始值；二要尽量采用系统采用的程序设计语言的语法规范描述属性。

方法设计包括数据结构设计、算法设计和流程设计。方法设计要注意的是：一要立足于所采用的程序设计语言；二所选用的程序设计语言应该能够提供丰富的数据结构；三要根据所实现的功能确定算法设计；四是可以用程序流程图或活动图来描述流程设计的结果。

#### 组件包设计

组件包包含被所有其他包使用的通用组件，图书管理系统的组件包由Const、DbChoice、BpUtil三个类组成，这三个类定义了系统所有其他类所使用的公共常量与公共方法。

#### 接口设计

* 用户界面
  * 独一无二的子系统
* 和其他系统、设备、网络或者其他信息生成者或者使用者的外部接口
  * 来源于需求工程
* 各种设计构件之间的内部接口，使得设计元素能够使软件进行外部通信，还能使软件体系结构中的构建之间进行内部通信和协作
  * 来源于DFD和PSPEC

#### ==分析建模和详细设计的关系==

##### ==面向对象==

==类、协作图：设计数据、体系结构和构件==

==用例、活动图：设计接口==

==状态图、顺序图：用来设计接口和构件==

##### ==面向过程==

==DFD：设计体系结构和接口==

==PSPEC：设计构件==

==STD、CSPEC：设计接口和构件==

==DD、ERD：设计数据==

详细设计就是构件设计，构件设计来源于：

构件是计算机软件中的一个模块化的构造块，系统中模块化的、可部署的和可替换的部件，该部件封装了实现并暴露一组接口

* 类、协作图：构件之间协作，属性设计，接口设计
* 状态图、顺序图：构件之间的接口设计
* STD、CSPEC、PSPEC：构件内部的方法和属性的设计
* 活动图：类内方法设计







# ==考试==

- safehome的所有图
- 详细设计和过程规约的关系
- uml中的关系与设计有什么关系
- 概要设计、详细设计与分析建模的关系
- 在dfd图中每个pop都有对应的pspec
- Process password 的加工规约
- 概要设计和详细设计和分析建模分别包括哪些内容
  - 图中下面三个是概要设计

如果有功能描述，详细设计的流程图直接以他作为依据画出来

pspec描述最后一次图中逻辑功能描述，如果逻辑描述对应一个模块，则直接以pspec的描述作为依据进行设计

详细设计与状态有关，因为从一个状态到另一个状态的时候要调用模块，和模块中的接口来处理

事件发生转移需要调用哪些模块需要在详细设计中体现出来

例如从正常状态到异常状态要调用显示这个功能

==期末考综合题==

use case

state

class d

class设计

业务类设计

非功能分析

**事务流的设计**

**变化流的设计**

**==考试：接口设计的名词解释：接口设计依据数据字典==**

接口设计描述了软件和协作系统之间、软件和使用人员之间是如何通信的。接口意味着信息流（数据和控制）和特定的行为类型。因此使用场景和行为模型为接口提供了大量信息

DFD怎么变成软件体系结构层次的调用关系

接口设计依据数据字典

### 类的简单描述

功能描述

输入项：方法被哪些类方法

调用其他哪些方法

不用写伪代码处理逻辑

答辩主要看核心业务类

### 敏捷模型

sprint iteration的周期是多少

建议时间2-4周

pattern是做什么的 

描述问题以及产生环境，并给出解决问题的方法

缺陷预算：

缺陷预算要cmm4以上才能用到 

评审为例：

walkthrough

1. 缺陷分类：计算类、接口类、需求类的缺陷

2. 1. 按照分类数量统计，从高到底排序

3. 按照80，20规则：找出占缺陷数量百分之八十的缺陷，某几个缺陷占总数量的百分之八十

4. 找到百分之八十的这些缺陷的真正的原因，root     cause

5. 进行预防

6. 第二轮代码

7. 占百分之八十的缺陷发生了变化

8. 循环以后总的缺陷数量下降

事件表

传感器

用户表

### 数据设计

属于详细设计

组件设计级别的

数据结构设计

数据库设计

数据仓库设计

# 系统工程==#掌握==

系统元素

硬件

软件

网络

人力

数据工程的建模

结构化建模

数据字典的描述

## 建模注意点

### 结构化建模分析和设计的关系

DFD

ERD

STD

知道跟设计的关系

三角原型图

数据字典

最后一层DFD建模数据的组织方式

最原始来自于ERD里面的属性的值

ERD是设计数据库表的基础

STD（state transaction diagram）是系统程序架构的设计基础==错==

DFD映射设计有两种：变化流、事务流

设计为软件体系结构模块的层次调用关系，衍生出接口设计

动态建模：状态图

静态建模：ERD，DFD

### 面向对象分析和设计的关系

依据需求规约中尤其是的use case图

根据需求初步构建类图

依据use case构建sequence diagram

根据类图某个业务类初步构建状态图

用活动图来描述类中的某个方法或者类甚至系统他们的业务流

得到初步的需求分析规约

面向对象中概要设计和详细设计没有分那么清楚

动态建模：状态图、时序图

其他的都是静态建模

# 作业

P37页作业

讨论题目：

1. 人工智能、机器学习、深度学习
   1. 人工智能一种应用
      1. 强人工智能，模拟人的行为
         1. 核心：模拟人大脑的思维方式
         2. 需要什么基础
      2. 弱人工智能，自学习能力或者没有或者很弱，没有运用机器学习
   2. 机器学习：一种方法
      1. 使用算法来解析数据
      2. 对真正的数据来进行预测
      3. 计算机视觉应用很成功
   3. 深度学习：一种学习深度学习的技术
   4. 神经网络的原理：需要大量的数据进行训练
2. 开源软件（系统类的开源软件、uml建模软件、单元测试的、软件开发、开源管理的开源软件）
3. 了解云计算并举例
4. Security和safety，目前在软件项目中各自涉及哪些方面。果做一个项目甲方达到某些要求，应该怎么实现。
5. 高德地图、百度地图怎么获得的实时准确的信息
   1. 提供路况服务的公司
   2. 终端设备回传数据，出租车上的GPS终端，每隔一定时间（10s~30s）就会向监测中心发送一次信息，这些信息包括车辆的位置信息，周围路况等等
   3. 使用导航APP的用户回传GPS信息
   4. 以政府的数据（交通指挥中心），摄像头的记录
6. 影响系统性能的因素
7. 找出一个tools进行分析
8. 找出一个pattern进行分析
9. 找出一些敏捷开发的实例和相关模板
10. 画出safehome系统的use case diagram，SID，ERD
11. **Function Point（FP） estimation method 项目的估算**
12. 缺陷预防



10门课，75学生选 

数量可以减少

考场数量

每个学生选择了部分课程             

设计考试的次数，以最短的考试时间考完

用什么数据结构存储数据

用算法实现考试的安排





## SAFEHOME实例

#### safehome有几个actor

户主

佣人

控制面板

液晶屏

喇叭

云平台主机系统

#### safehome的用例图

成功

异常

用户名

密码

验证码

对应四个序列图，因为返回的对象有所不同

登录的时候调用一个显示的类，对login的接口显示化，有一个模拟信号到物理信号的转换

输入处理检查

数据库处理类

显示功能处理类

序列图直接用来验证use case产品功能的正确性

Use case中的功能动作根据序列图进行细化

## 工厂实例

### ERD练习

回去画一遍图

注意erd中一对一一对多的关系

一个车间生产多种产品，是不是一个产品只能被一个车间生产

需要进一步核实

车间和零件之间是多对多的关系

#### n对n

一种零件放在某个仓库中

一种产品可以放在多个仓库中

多对多：

零件和产品

零件和车间

#### 一对多

仓库和产品

车间和产品

仓库和零件

车间和工人

工厂和车间

#### 一对一

创建两个表，关系属性放到任何一个表中

实体一定要定义一个主键，可以使用组合属性作为主键

主键也要放在关系属性放的一边

#### ER图到表构造

一对多构建两个表，关系属性放到多的一遍

主键也要放在多的一遍

多对多的关系构建两个表

取出两个主键构成新表





# 图

## 面向对象分析建模

五个分离而又相互联系的面向对象的模型或图被用于从面向对象的角度出发来定义应用需求。

这五种图是（1）类图。（2）用例图。（3）协作图。（4）顺序图。（5）状态图。

但有些情况只需三四种图即可准确的定义需求。

### 类图class diagram

**类图**的目的是识别组成新系统的对象并进行分类。在类图中，还要识别每个需要记录的对象属性或特性。比如说，RMO系统包含客户对象，因此我们定义了客户类，这个类包含了每个客户都有的属性。通常，用一个综合图来显示整个系统中所有的类和关系，运动品销售系统的类图。  

### 用例图use case diagram

**用例图**的目的是识别新系统的“使用”，或用例，换句话说，就是识别如何使用系统。用例图本质上是事件表的延伸。用例图是一个记录系统必须支持功能的简便方法。有时可以用一个综合的用例图来描述整个系统。在其他情况下，一些小型的用例图组成用例模型。

  **用例图是一种用以显示不同的用户角色和这些用户角色如何使用系统的图。**

### 协作图

**协作图**的目的是识别协作完成给定业务功能的对象。比如说，一个RMO系统的业务用途之一是“记录客户订单”，那么协作表将会识别所有涉及到的对象。为了**记录客户订单需要一个客户对象、一些库存对象和一个新订单对象**等等。一个单一的协作图用以识别对象，并展示这些对象的相互作用及对象之间发送用于执行功能的消息。通常说来，我们会用到许多协作图。

**协作图是一种用以显示对象如何被协调在一起以执行用例的图。**

### 顺序图sequence diagram

**消息**：用例内部的对象之间的通信。

  **顺序图**与协作图所表达的信息是一样的，只是显示方式有些差异。顺序图以图形化的方式强调消息间的顺序，而非协作对象间的顺序。画顺序图的目的是为了通过页面上位置图形化的表示消息的顺序。执行次序从上到下进行。协作图和顺序图都统称作交互图。

**顺序图是一种用以显示用例对象之间消息顺序的图**

### 状态图status diagram

最后一种被用以描述应用需求的图称作状态图。一个状态图表（或简单的称之为状态图）描述了每个对象的状态和行为。每一个对象累都含有一个状态图表。在状态图的内部是动作陈述，这些动作陈述在最终的系统中都变成了逻辑。每个类中的逻辑组件称为方法。

  **状态图**：**一种用以显示对象在生命期和转换期情况的图**。



**==OO需求=事件表+类图+用例图+交互图（协作图和/或顺序图）+状态图表==**



## 结构化技术

### 数据流图DFD

- 当从一个级到下一级时要维护“**信息流的连续性**”，即一个子图必需对应父图的一个加工，两者的输入和输出数据流必需一致，实现父图与子图的平衡。
- 在分层使用DFD图描述中，重要的一点父图与子图的**平衡**，即子图必需是父图中的一项处理加工项，编号应有顺序
- 层次结构的上一层是下一层的抽象，下一层是上一层的求精

### 状态变迁图STD

### 实体关系图ERD



### **用例图与结构化技术的比较** 

用例图的目标是提供一个系统的概览，包括使用这个系统地参与者和这个系统执行的功能。从这个意义上来讲，它定义了系统的范围，因此用例图与关联图类似，但是，单个用例在标识系统支持的功能方面来说更像是DFD片段。

  结构化建模和面向对象建模的一个主要差别在于开发一个最初定义自动化边界的用例图的思维过程。在DFD的开发中，自动化边界只在所有的过程已被细化后才确定。所以，在DFD中外部实体总是信息的源和目的。而且它可以不必是一个与系统交互的实体。在用例图中，不管这个参与者是不是信息的源，它都是系统交互的实体。

  例如，在RMO实例中，一个客户也许会打电话给一个RMO职员订货。DFD会把外部实体看作客户。职员的活动可以包含在称为“输入客户订单”的过程中。在这个用例图中，职员标识为使用系统来进入或创建订单的参与者。

  另一个重要的差别是用例图不显示数据流。流进和流出系统的信息只有到下一层建模的交互图中才得以体现。

  开发用例图 开发用例图有两个切入点。最常用的方法是使用事件表。我们分析表中的每一个时间以决定系统支持这个事件的方式。初始化这个事件的参与者，以及由于这个事件而可能触发的其他用例。通常，每一个事件都是一个用例。但有时一个事件可能产生多个用例。

  开发用例图的另一个切入点是确定所有使用系统的参与者。通过查找在事件表中的触发器和来源的所在列，就可以建立一个参与者列表。



## 两种建模对比

传统的结构化方法与面向对象的方法之间的区别并不在于方法上的不同，而是在于所用的模型。每种方法的SDLC都含有相同的阶段：规划、分析、设计和实施。==每个阶段的活动也是相同的。但所用的模型不同。

由于每个活动的人物都是以建立模型为中心的，因此这些任务也是不同的。

相同：活动，两种方法都开始于事件表，并都要求识别事物

不同：模型、任务、最基本的区别是用来表示过程和系统行为的图或模型的不同。

> 传统方法：（过程+实体）  
> ​      把系统看作一个过程的集合体。  
> ​      过程与数据实体交互。过程接受输入并产生输出。  
>
>   OO方法：（对象+消息）  
> ​      把系统看成是一个相互影响的对象集。  
> ​      对象之间通过发送和响应消息进行交互。  
>
>   从过程到OO不是简单地一个升级。  
>   传统方法强调“过程模型+实体模型”。  
>   OO方法强调“对象模型+对象交互”。  
>   不可能将传统方法的思维应用于OO方法中。  
>
>   传统方法用“数据流图+数据字典”来描述系统需求。  
>   数据流图包括外部实体、过程、数据流和数据存储等DFD部件。  
>   数据字典则是对DFD部件的定义，包括过程描述、数据流定义、数据元素定义和数据存储定义。  
>
>   OO方法用5种图来定义系统需求：类图+用例图+协作图+顺序图+状态图。

## 需求建模方法对比DFD,ERD,USD

> 用于需求建模的方法有很多种，最常用的包括数据流图（DFD）、实体关系图（ERD）和用例图（Use Case）三种方式。DFD作为结构化系统分析与设计的主要方法，已经得到了广泛的应用，DFD尤其适用于MIS系统的表述。DFD使用四种基本元素来描述系统的行为，过程、实体、数据流和数据存储。DFD方法直观易懂，使用者可以方便地得到系统的逻辑模型和物理模型，但是从DFD图中无法判断活动的时序关系。图2描述的是某个项目的DFD示意图。
> 　　ERD方法用于描述系统实体间的对应关系，需求分析阶段使用ERD描述系统中实体的逻辑关系，在设计阶段则使用ERD描述物理表之间的关系。需求分析阶段使用ERD来描述现实世界中的对象。ERD只关注系统中数据间的关系，而缺乏对系统功能的描述。如果将ERD与DFD两种方法相结合，则可以更准确地描述系统的需求。
> 　　在面向对象分析的方法中通常使用Use Case来获取软件的需求。Use Case通过描述“系统”和“活动者”之间的交互来描述系统的行为。通过分解系统目标，Use Case描述活动者为了实现这些目标而执行的所有步骤。Use Case方法最主要的优点，在于它是用户导向的，用户可以根据自己所对应的Use Case来不断细化自己的需求。此外，使用Use Case还可以方便地得到系统功能的测试用例。

## 需求分析

### 用例图

### 功能

==Use-case 描述了**参与者和系统的交互方式**。==

一个use-case只是简单的一段叙述，描述参与者在和系统交互时的角色

本质上，用例讲述了能表达主体场景的故事：最终用户（扮演多种可能角色中的一个）如何在一特定的的环境下和系统交互。

1. 帮助我们从产品的角度理解需求
2. 对于复杂系统测试的重要依据

### 步骤

#### 确定“参与者”

1）分析员必须首先标识使用系统或产品的**不同类型**的参与者，参与者有主要参与者和次要参与者。

- 参与者是在将要说明的功能和行为环境内使用**系统**或者**产品的各类人员**。
- 参与者代表了系统运行时候人（或设备）所扮演的**角色**
- 参与者是任何与系统或产品通信的事物，且对系统本身而言参与者是**外部**的。

#### 参与者和最终用户

参与者和最终用户并非一回事，典型的用户可能在使用系统时扮演了许多不同的角色，而**参与者表示了一类外部实体，在用例中仅仅扮演一种角色**。

例如一个机床操作员可以分解为：程序员、测试员、监控员和故障检修员

#### SAFEHOME实例

safehome中四个重要参与者：

- 房主（用户）
- 配置管理人员（很可能就是房主，扮演不同的角色）
- 传感器（附属于系统的设备）
- 检测子系统（检测safehome房间安全功能的中央站）

#### safehome有几个actor

户主

佣人

控制面板

液晶屏

喇叭

云平台主机系统

## 序列图

### 功能

==序列图直接用来验证use case产品功能的正确性==

==Use case中的功能动作根据序列图进行细化==

1. 序列图中的动态交互来验证需要哪些类和功能构成
2. 分析的时候序列图是粗放的，设计的时候是详细细化

分析的时候每个类的属性只有简单的方法，属性的类型都可以没有，方法也不够完整

### 实例

##### 成功

##### 异常

用户名

密码

验证码

对应**四个序列图**，因为返回的对象有所不同

登录的时候调用一个显示的类，对login的接口显示化，有一个模拟信号到物理信号的转换

输入处理检查

数据库处理类

显示功能处理类



## 分析建模

分析建模的主要目标：

1）描述客户的需求

2）创建软件设计的基础

3）定义在软件完成后可以确认的一组需求

步骤：

数据建模：类图、ER图

功能建模

行为建模

### 状态图

每个类都有状态图

细化：有什么事件，类内方法调用，类间方法调用

### ERD

##### 对象确定objects

名词或者名词词组：实体、潜在类（entity，potential class）

名词包含属性（系统需要处理的原始数据），选择我们需要的属性来构造出我们的实体

传感器、电话号码、警报、控制面板、门窗传感器、显示器、计算机、电话

##### 功能确定functions

动词和动词词组代表实体之间的关系

配置系统、设置警报器、检测传感器、电话拨号、控制面板编程、读写显示器、异常处理 

##### 限制constrains

用来描述关系的属性

成本、规模、大小、业务规则

不能用脉冲信号，只能用数字信号，特定传感器，操作系统，有线和无线结合，成本约束

##### 性能performance

速度，精度

##### 输出：初步的需求规约草稿draft

use case diagram 

## 活动图

模块流程图

活动图可以描述类、方法的逻辑

类中的方法需要有非常详细的设计

没有属性只有方法的类

通用的类

显示出来等等

只有属性没有方法的类

## 流程图

需求调研

用例图

建模

分析建模

设计建模

尤其是每个类中的定义

依据类来设计数据库

### ==DFD到软件体系结构==

两种DFD的类型

==考试考大题==

软件体系结构是概要设计中的重要部分

architecture

#### DFD两种类型

##### 基于变化流的形式

transform

某一个流或者多个流经过bubble分析以后可以从多个流流出

incoming flow

变换中心transform center

##### 基于事务流的形式

transaction

每一种流经过bubble分析以后只能沿着一个流出去

流入：

transaction

处理：

transaction center

输出：

action paths

在设计的时候DFD要分析类型，是变化类还是事务类

#### 变换流设计：

safehome系统最后一层的dfd图

1. 识别变化流和事务流

2. 划分边界

   ​把incoming flow 和transform center 和outgoing flow隔离出来

   通过一条线隔离

   基本原则，调用不能太深

3. 创建主控模块CM（得到初步的体系结构）

   SM1，SM2，SM3

   每一个模块对应一个pspec

   incoming flow映射到左边

   新输入的映射到叶子

   后输出的叶子在下面

4. 优化

   内爆：两个节点合并成一个，两个功能太简单并且内部还有很多调用

   外爆：一个节点爆成两个，加一个控制模块

   如果一直往下调用会影响最后的性能

每一条线都是call return

CM相当于Main主函数

一个分支的模块主要做输入流，一个模块主要跟处理有关，一个跟输出相关

应用子程序的接口设计就根据掉用户调用事务设计

控制模块和子应用模块的接口设计根据两个模块之间的关系设计

#### 事务流设计：

==期末考试：transaction mapping的图15分题目==

每一个action path又有变化流，又有事务流

a、b：transaction

d：transaction center

三个action path

增加一个transaction control

把transaction画在左边，先输入的放在下面

事务中心下面增加三个控制模块，把action path添加到控制模块下面

#### 画图流程

主控模块

有三个模块，分成三个自控模块

最下面的分支增加三个控制模块

注意方块的部分是到数据库中读取数据，不需要画出来

因为是被动的输入，不是主动的输入，所以不考虑

删除不必要的控制模块

接口：

- 直接来自数据字典，作为数据流的同一个分支
- 以数据字典的设计为依据，从直接交互变为先传数据给控制模块，再间接交互：属于不同分支

对三个分支进行分析，看是事务流还是变化流

变化流，增加主控模块，对于incoming center outgoing 增加三个子控模块，只管理一个流的控制模块可以删去

d事务中心，action path有变化流和事务流

### 详细设计

针对每一个模块进行设计：尤其是叶子

限制条件，异常处理：密码位数不够，不是字母

输出项（被其他模块调用）

输入项（调用其他模块）

status初步类设计

activity diagram可以用于某个方法，某个类的逻辑设计

概要设计中初步的class diagram和status diagram为依据

类设计以状态图

接口以sequence diagram

一个use case对应一个或多个sequence diagram